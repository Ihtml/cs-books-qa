### 1. 什么是前趋图?为什么要引入前趋图?
答:前趋图(Precedence Graph)是一个**有向无循环图**，记为DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。

### 3. 什么程序并发执行会产生间断性特征?
答:程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。

### 4.程序并发执行时为什么会失去封闭性和可再现性? 
答:程序并发执行时，**多个程序共享系统中的各种资源，因而这些资源的状态由多个程序改变，**致使程序运行失去了封闭性，也会导致其失去可再现性。

### 5.在操作系统中为什么要引入进程概念?
它会产生什么样的影响? 答:为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操 作系统中引入了进程概念。
影响: 使程序的并发执行得以实行。

### 6.试从动态性，并发性和独立性上比较进程和程序? 
答:(1)**动态性**是**进程最基本的特性**，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。
(2)**并发性**是进程的重要特征，同时也是OS 的重要特征。**引入进程的目的正是为了使其程序能和其它进程的程序并发执行**，而程序是不能并发执行的。 
(3)**独立性**是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。

### 7.试说明PCB 的作用，为什么说PCB 是进程存在的惟一标志?
答:PCB 是进程实体的一部分，是操作系统中最重要的记录型数据结构。作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程。OS是根据PCB对并发执行的进程进行控制和管理的。

### 8.试说明进程在三个基本状态之间转换的典型原因。
答: (1)就绪状态→执行状态:进程分配到CPU资源 
(2)执行状态→就绪状态:时间片用完
(3)执行状态→阻塞状态:I/O请求
(4)阻塞状态→就绪状态:I/O完成

### 9.为什么要引入挂起状态?该状态有哪些性质?
答:引入挂起状态处于五种不同的需要: 终端用户需要，父进程需要，操作系统需要，对换需要和负荷调节需要。处于挂起状态的进程不能接收处理机调度。

### 10.在进行进程切换时，所要保存的处理机状态信息有哪些? 
答:进行进程切换时，所要保存的处理机状态信息有:
(1)进程当前暂存信息
(2)下一指令地址信息
(3)进程状态信息
(4)过程和系统调用参数及调用地址信息。

### 11.试说明引起进程创建的主要事件。 
答:引起进程创建的主要事件有:用户登录、作业调度、提供服务、应用请求。 

### 12.试说明引起进程被撤销的主要事件。 
答:引起进程被撤销的主要事件有:正常结束、异常结束(越界错误、保护错、非法指令、 特权指令错、运行超时、等待超时、算术运算错、I/O 故障)、外界干预(操作员或操作系 统干预、父进程请求、父进程终止)。

### 13.在创建一个进程时所要完成的主要工作是什么?
答:
(1)OS 发现请求创建新进程事件后，调用进程创建原语Creat(); 
(2)申请空白PCB;
(3)为新进程分配资源; (4)初始化进程控制块; (5)将新进程插入就绪队列

### 14.在撤销一个进程时所要完成的主要工作是什么? 
答:
(1)根据被终止进程标识符，从PCB 集中检索出进程PCB，读出该进程状态。 
(2)若被终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被 终止后重新调度。 
(3)若该进程还有子进程，应将所有子孙进程终止，以防它们成为不可控进程。 
(4)将被终止进程拥有的全部资源，归还给父进程，或归还给系统。 
(5)将被终止进程PCB 从所在队列或列表中移出，等待其它程序搜集信息。

### 15.试说明引起进程阻塞或被唤醒的主要事件是什么?
答:a. 请求系统服务;b. 启动某种操作;c. 新数据尚未到达;d. 无新工作可做.

### 16.进程在运行时存在哪两种形式的制约?并举例说明之。
答:
(1)间接相互制约关系。举例:有两进程A 和B，如果A 提出打印请求，系统已把唯一的 一台打印机分配给了进程B，则进程A 只能阻塞;一旦B 释放打印机，A 才由阻塞改为就 绪。
(2)直接相互制约关系。举例:有输入进程A 通过单缓冲向进程B 提供数据。当缓冲空时， 计算进程因不能获得所需数据而阻塞，当进程A 把数据输入缓冲区后，便唤醒进程B;反 之，当缓冲区已满时，进程A 因没有缓冲区放数据而阻塞，进程B 将缓冲区数据取走后便 唤醒A。

### 17.为什么进程在进入临界区之前应先执行“进入区”代码?而在退出前又要执行“退出 区”代码? 
答:为了实现多个进程对临界资源的互斥访问，必须在临界区前面增加一段用于检查欲访问的临界资源是否正被访问的代码，如果未被访问，该进程便可进入临界区对资源进行访问， 并设置正被访问标志，如果正被访问，则本进程不能进入临界区，实现这一功能的代码为" 进入区"代码;在退出临界区后，必须执行"退出区"代码，用于恢复未被访问标志，使其它进程能再访问此临界资源。

### 18. 同步机构应遵循哪些基本准则?为什么? 
答:同步机构应遵循的基本准则是:**空闲让进、忙则等待、有限等待、让权等待** 
原因:为实现进程互斥进入自己的临界区。

### 19. 试从物理概念上说明记录型信号量wait 和signal。
答:wait(S):当S.value>0 时，表示目前系统中这类资源还有可用的。执行一次wait 操 作，意味着进程请求一个单位的该类资源，使系统中可供分配的该类资源减少一个，因此描 述为S.value:=S.value-1;当S.value<0时，表示该类资源已分配完毕，进程应调用block 原语自我阻塞，放弃处理机，并插入到信号量链表S.L中。 signal(S):执行一次signal操作，意味着释放一个单位的可用资源，使系统中可供分配 的该类资源数增加一个，故执行S.value:=S.value+1 操作。若加1 后S.value≤0，则表 示在该信号量链表中，仍有等待该资源的进程被阻塞，因此应调用wakeup 原语，将S.L 链表中的第一个等待进程唤醒。

### 20.你认为整型信号量机制是否完全遵循了同步机构的四条准则? 
答:整型信号量机制不完全遵循同步机制的四条准则，它不满足“让权等待”准则。

### 21.如何利用信号量机制来实现多个进程对临界资源的互斥访问?并举例说明之。
 答:为使多个进程互斥访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作之间即可。这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex 执行 wait 操作，若该资源此刻未被访问，本次wait 操作必然成功，进程便可进入自己的临界区， 这时若再有其他进程也欲进入自己的临界区，此时由于对mutex 执行wait操作定会失败， 因而该进程阻塞，从而保证了该临界资源能被互斥访问。当访问临界资源的进程退出临界区后，应对mutex执行signal 操作，释放该临界资源。利用信号量实现进程互斥的进程描述.

### 23.在生产者消费者问题中，如果缺少了signal(full)或signal(empty),对执行结果有何 影响? 
答:如果缺少signal(full)，那么表明从第一个生产者进程开始就没有改变信号量full 值，即使缓冲池产品已满，但full 值还是0，这样消费者进程执行wait(full)时认为缓冲池是空 而取不到产品，消费者进程一直处于等待状态。
如果缺少signal(empty)，在生产者进程向n个缓冲区投满产品后消费者进程才开始从中取产品，这时empty=0，full=n，那么每当消费者进程取走一个产品empty 值并不改变， 直到缓冲池取空了，empty 值也是0，即使目前缓冲池有n 个空缓冲区，生产者进程要想再往缓冲池中投放产品也会因为申请不到空缓冲区被阻塞。

### 24.在生产消费者问题中，如果将两个wait 操作即wait(full)和wait(mutex)互换位置， 或者将signal(mutex)与signal(full)互换位置，结果如何? 
答:将wait(full)和wait(mutex)互换位置后，可能引起死锁。考虑系统中缓冲区全满时， 若一生产者进程先执行了wait(mutex)操作并获得成功，则当再执行wait(empty)操作时， 它将因失败而进入阻塞状态，它期待消费者进程执行signal(empty)来唤醒自己，在此之前， 它不可能执行signal(mutex)操作，从而使试图通过执行wait(mutex)操作而进入自己的临界区的其他生产者和所有消费者进程全部进入阻塞状态，这样容易引起系统死锁。 若signal(mutex)和signal(full)互换位置后只是影响进程对临界资源的释放次序，而不会引起系统死锁，因此可以互换位置。

### 29.说明管程由哪几部分组成，为什么要引入条件变量?
答:管程由四部分组成:1管程的名称;2局部于**管程内部的共享数据结构说明**;3对该数 据结构进行操作的一组过程;4对局部于管程内部的共享数据设置初始值的语句;
当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间地等待。为了解决这个 问题，引入了**条件变量condition**。


### 30.如何利用管程来解决生产者与消费者问题?
答:首先建立一个管程，命名为ProclucerConsumer，包括两个过程:
(1)Put(item)过程。生产者利用该过程将自己生产的产品放到缓冲池，用整型变
量count 表示在缓冲池中已有的产品数目，当count≥n 时，表示缓冲池已满，生产者须
等待。
(2)get(item)过程。消费者利用该过程从缓冲池中取出一个产品，当count≤0
时，表示缓冲池中已无可取的产品，消费者应等待。
PC 管程可描述如下:
```
type producer-consumer =monitor
Var in,out,count:integer;
buffer:array[0,...,n-1]of item;
notfull，notempty:condition;
procedure entry dot(item)
   begin
       if count>=n then not full.wait;
       buffer(in):=nextp;
       in:=(in+1)mod n;
       count:=count+1;
       if notempty.queue then notempty.signal;
     end
procedure entry get(item)
     begin
       if count<=0 then not full.wait;
       nextc:=buffer(out);
       out:=(out+1)mod n;
       count:=count-1;
       if notfull.quene then notfull.signal;
     end
begin in:=out:=0;
count:=0
end
```
在利用管程解决生产者一消费者问题时，其中的生产者和消费者可描述为:
```
producer: begin
   pepeat
    produce an inem in nestp
    PC.put(item);
    until false;
   end
consumer: begin
repeat
    PC.get(item);
    consume the item in enxtc;
    until false;
end
```

### 31.什么是AND信号量?试利用AND信号量写出生产者一消费者问题的解法。 
答:为解决并行带来的死锁问题，在wait 操作中引入AND 条件，其基本思想是**将进 程在整个运行过程中所需要的所有临界资源，一次性地全部分配给进程，用完后一次性释放。**


### 33.试比较进程间的低级与高级通信工具。 
答:用户用低级通信工具实现进程通信很不方便，效率低，通信对用户不透明，所有操作都 必须由程序员来实现，而高级通信工具弥补了这些缺陷，用户直接利用操作系统提供的一组通信命令，高效地传送大量的数据。

### 34.当前有哪几种高级通信机制? 
答:**共享存储器系统**、**消息传递系统**以及**管道通信系统**。


### 35.消息队列通信机制有哪几方面的功能? 
答:(1)构成消息(2)发送消息(3)接收梢息(4)互斥与同步。