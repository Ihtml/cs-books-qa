- [问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?](#问题-5-1-tcp-协议是面向连接的但-tcp-使用的-ip-协议却是无连接的这两种协议都-有哪些主要的区别)
- [问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?](#问题5-2-从通信的起点和终点来比较-tcp和ip的不同点是什么)
- [问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么?](#问题-5-3-ip和-udp-的一个共同点就是它们都是无连接-的-ip和-udp-最主要的区别是什么)
- [问题 5-4. 端口(port)和套接字(socket)的区别是什么?](#问题-5-4-端口port和套接字socket的区别是什么)
- [问题 5-5 一 个套接字能否同时与远地的两个套接字相连?](#问题-5-5-一-个套接字能否同时与远地的两个套接字相连)
- [问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?](#问题5-6数据链路层的hdlc协议和运输层的tcp协议都使用滑动窗口技术从这方面来进行比较数据链路层协议和运输层协议的主要区别是什么)
- [问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?](#问题5-7tcp协议能够实现可靠的端到端传输在数据链路层和网络层的传输还有没有必要来保证可靠传输呢)
- [问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?](#问题5-8在tcp报文段的首部中只有端口号而没有ip地址当tcp将其报文段交给ip层时ip协议怎样知道目的ip地址呢)
- [问题5-9在TCP传送数据时，有没有规定一个最大重传次数?](#问题5-9在tcp传送数据时有没有规定一个最大重传次数)
- [问题5-10.TCP都使用哪些计时器?](#问题5-10tcp都使用哪些计时器)
- [问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?](#问题-5-11-是否-tcp-和-udp-都需要计算往返时间-rtt)
- [问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?](#问题5-12假定tcp开始进行连接建立当tcp发送第一个syn报文段时显然无法利用教材中562节所介绍的方法计算往返时间rtt那么这时tcp又怎样设置重传计时器呢)
- [问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?](#问题-5-13-糊涂窗口综合征产生的条件是什么是否只有在接收方才产生这种症状)
- [问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?](#问题-5-14-能否更详细地讨论-一-下糊涂窗口综合征及其解决方法)
- [问题 5-15 为什么TCP什让汒连接盯小能每次都选择相同的、固定的初始序号?](#问题-5-15-为什么tcp什让汒连接盯小能每次都选择相同的固定的初始序号)
- [问题 5-16. 能否利用 TCP 发送端和接收端交换报文段的图来说明慢开始的特点?](#问题-5-16-能否利用-tcp-发送端和接收端交换报文段的图来说明慢开始的特点)
- [问题 5-17. 对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理?](#问题-5-17-对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理)
- [问题 5-18. TCP连接很像一条连接发送端和接收端的双向管道。当 TCP在连续发送报文段时，若要管道得到充分的利用，则发送窗口的大小应怎样选择?](#问题-5-18-tcp连接很像一条连接发送端和接收端的双向管道当-tcp在连续发送报文段时若要管道得到充分的利用则发送窗口的大小应怎样选择)
- [问题5-19. 假定在一个互联网中，所有的链路的传输都不出现差错，所有的结点也都不会发生故障。试间在这种情况下， TCP 的”可靠交付"的功能是否就是多余的?](#问题5-19-假定在一个互联网中所有的链路的传输都不出现差错所有的结点也都不会发生故障试间在这种情况下-tcp-的可靠交付的功能是否就是多余的)
- [问题5-20. TCP是通信协议还是软件?](#问题5-20-tcp是通信协议还是软件)
- [问题5-21.在计算TCP的往返时间RTT的公式中，《计算机网络》教材过去的版本是取a=7/8。但在第6版和第7版中是取a=1/8。为什么会有这样大的改变?](#问题5-21在计算tcp的往返时间rtt的公式中计算机网络教材过去的版本是取a78但在第6版和第7版中是取a18为什么会有这样大的改变)
- [问题 5-22 假定有一个应用程序需要知道报文从发送端到接收端所经受的时延。能否这样计算:从TCP获得往返时间RTT的数值。然后除以2?](#问题-5-22-假定有一个应用程序需要知道报文从发送端到接收端所经受的时延能否这样计算从tcp获得往返时间rtt的数值然后除以2)
- [问题 5-23. 教材上的图 5-7 在计算 UDP 检 验和时，为什么有的读者算出的“求和得出的 结果”是 1001011011101011, 而不是教材上给出的 10010110 1110110I?](#问题-5-23-教材上的图-5-7-在计算-udp-检-验和时为什么有的读者算出的求和得出的-结果是-1001011011101011-而不是教材上给出的-10010110-1110110i)
- [问题 5-24. TCP 的客户端和服务器端在交换数据时，为什么不含数据的确认报文段不消耗序号呢?](#问题-5-24-tcp-的客户端和服务器端在交换数据时为什么不含数据的确认报文段不消耗序号呢)
- [问题 5-25. TCP 在连接建立时所发送的第一个 SYN 报文段只有首部，其数据部分是空的。 但为什么 SYN 报文段要消耗一个序号呢?](#问题-5-25-tcp-在连接建立时所发送的第一个-syn-报文段只有首部其数据部分是空的-但为什么-syn-报文段要消耗一个序号呢)
- [问题 5-26. TCP 在连接建立时，A发送SYN报文段，选择了初始序号seq=x。B收到连接请求报文段后，如同意建立连接，则向A发送确认和SYN报文段，其确认号是ack = x + 1, 同时也为自己选择一个初始序号 seq=y。 A 最后要发送确认报文段， 其序号是 seq= x + 1, 确认号是 ack = y + I 。这个确认 报文段消耗序号吗?](#问题-5-26-tcp-在连接建立时a发送syn报文段选择了初始序号seqxb收到连接请求报文段后如同意建立连接则向a发送确认和syn报文段其确认号是ack--x--1-同时也为自己选择一个初始序号-seqy-a-最后要发送确认报文段-其序号是-seq-x--1-确认号是-ack--y--i-这个确认-报文段消耗序号吗)
- [问题 5-27. TCP 连接建立采用的 Three-Way Handshaking 的准确译名应当是怎样的?](#问题-5-27-tcp-连接建立采用的-three-way-handshaking-的准确译名应当是怎样的)
- [问题 5-28. TCP 报文段的长度有没有规定的最小值和最大值?](#问题-5-28-tcp-报文段的长度有没有规定的最小值和最大值)
- [问题 5-29. 能否这样讲:当我们在互联网上传送很长的大文件时，就必须使用 TCP 协议 而不是使用 UDP 协议?](#问题-5-29-能否这样讲当我们在互联网上传送很长的大文件时就必须使用-tcp-协议-而不是使用-udp-协议)
- [习题与解答](#习题与解答)
- [【5-01 】 试说明运输层在协议栈中的地位和作用。运输层的通信和网络层的通信有什么 重要的区别?为什么运输层是必不可少的?](#5-01--试说明运输层在协议栈中的地位和作用运输层的通信和网络层的通信有什么-重要的区别为什么运输层是必不可少的)
- [<5-02 > 网络层提供数据报或虚电路服务，对上面的运输层有何影响?](#5-02--网络层提供数据报或虚电路服务对上面的运输层有何影响)
- [<5-03 > 当应用程序使用面向连接的 TCP 和无连接的IP时，这种传输是面向连接的还是无连接的?](#5-03--当应用程序使用面向连接的-tcp-和无连接的ip时这种传输是面向连接的还是无连接的)
- [【5-04】试画图解释运输层的复用。画图说明许多个运输用户复用到 一 条运输连接上， 而这条运输连接又复用到 IP 数据报上。](#5-04试画图解释运输层的复用画图说明许多个运输用户复用到-一-条运输连接上-而这条运输连接又复用到-ip-数据报上)
- [【5-05】试举例说明有些应用程序愿意采用不可靠的 UDP, 而不愿意采用可靠的 TCP。](#5-05试举例说明有些应用程序愿意采用不可靠的-udp-而不愿意采用可靠的-tcp)
- [<5-06 > 接收方收到有差错的 UDP 用户数据报时应如何处理?](#5-06--接收方收到有差错的-udp-用户数据报时应如何处理)
- [<5-07> 如果应用程序愿意使用 UDP 完成可靠传输，这可能吗?请说明理由 。](#5-07-如果应用程序愿意使用-udp-完成可靠传输这可能吗请说明理由-)
- [<5-08> 为什么说 UDP 是面向报文的，而 TCP 是面向字节流的?](#5-08-为什么说-udp-是面向报文的而-tcp-是面向字节流的)
- [<5-09 > 端口的作用是什么?为什么端口号要划分为三种?](#5-09--端口的作用是什么为什么端口号要划分为三种)
- [<5-10 > 试说明运输层中伪首部的作用 。](#5-10--试说明运输层中伪首部的作用-)
- [【5-11 】 某个应用进程使用运输层的用户数据报UDP,然后继续向下交给IP层后，又封装成IP数据报。既然都是数据报，是否可以跳过UDP而直接交给IP层?哪些功能UDP提供了但IP没有提供?](#5-11--某个应用进程使用运输层的用户数据报udp然后继续向下交给ip层后又封装成ip数据报既然都是数据报是否可以跳过udp而直接交给ip层哪些功能udp提供了但ip没有提供)
- [【5-12】 一个应用程序用UDP,到了JP层把数据报再划分为4个数据报片发送出去。结果前两个数据报片丢失，后两个到达目的站。过了一段时间应用程序重传UDP,而IP层仍然划分为4个数据报片来传送。结果这次前两个到达目的站而后两个丢失。试问:在目的站能否将这两次传输的4个数据报片组装成为完整的数据报?假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中。](#5-12-一个应用程序用udp到了jp层把数据报再划分为4个数据报片发送出去结果前两个数据报片丢失后两个到达目的站过了一段时间应用程序重传udp而ip层仍然划分为4个数据报片来传送结果这次前两个到达目的站而后两个丢失试问在目的站能否将这两次传输的4个数据报片组装成为完整的数据报假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中)
- [【5-13】 一个 UDP 用户数据报的数据字段为 8192 字节。在链路层要使用以太网来传送。 试问应当划分为几个 IP 数据报片?说明每一个 IP 数据报片的数据字段长度和片偏移字段的值。](#5-13-一个-udp-用户数据报的数据字段为-8192-字节在链路层要使用以太网来传送-试问应当划分为几个-ip-数据报片说明每一个-ip-数据报片的数据字段长度和片偏移字段的值)
- [【5-14】 一个 UDP 用户数据报的首部的十六进制表示是: 06 32 00 45 00 1C E2 17。试 求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报 是从客户发送给服务器还是从服务器发送给客户?使用 UDP 的这个服务器程序是什么?](#5-14-一个-udp-用户数据报的首部的十六进制表示是-06-32-00-45-00-1c-e2-17试-求源端口目的端口用户数据报的总长度数据部分长度这个用户数据报-是从客户发送给服务器还是从服务器发送给客户使用-udp-的这个服务器程序是什么)
- [【5-15】使用 TCP 对实时话音数据的传输有没有什么问题?使用 UDP 在传送数据文件时会有什么问题?](#5-15使用-tcp-对实时话音数据的传输有没有什么问题使用-udp-在传送数据文件时会有什么问题)
- [<5-16 > 在停止等待协议中，如果不使用编号是否可行?为什么?](#5-16--在停止等待协议中如果不使用编号是否可行为什么)
- [<5-17>在停止等待协议中，如果收到重复的报文段时不予理睬(即悄悄地丢弃它 ， 而其他什么也不做)是否可行?试举出具体例子说明理由。](#5-17在停止等待协议中如果收到重复的报文段时不予理睬即悄悄地丢弃它--而其他什么也不做是否可行试举出具体例子说明理由)
- [【5-18】假定在运输层使用停止等待协议。发送方在发送报文段 M。后在设定的时间内 未收到确认，千是重传 M。，但 M。又迟迟不能到达接收方 。 不久，发送方收到 了迟到的对 M。的确认，于是发送下 一 个报文段 M,, 不久就收到了对 M, 的确 认。接着发送方发送新的报文段 M。，但这个新的 M。在传送过程中丢失了。正 巧， 一 开始就滞留在网络中的 M。现在到达接收方。接收方无法分辨出 M。是旧 的。千是收下 M。，并发送确认。显然，接收方后来收到的 M。是重复的，协议 失败了 。试画出双方交换报文段的过程。](#5-18假定在运输层使用停止等待协议发送方在发送报文段-m后在设定的时间内-未收到确认千是重传-m但-m又迟迟不能到达接收方--不久发送方收到-了迟到的对-m的确认于是发送下-一-个报文段-m-不久就收到了对-m-的确-认接着发送方发送新的报文段-m但这个新的-m在传送过程中丢失了正-巧-一-开始就滞留在网络中的-m现在到达接收方接收方无法分辨出-m是旧-的千是收下-m并发送确认显然接收方后来收到的-m是重复的协议-失败了-试画出双方交换报文段的过程)
- [【5-19】试证明: 当用 n 比特进行分组的编号时，若接收窗口等于 1 (即只能按序接收分组)，则仅在发送窗口不超过 2n- I 时，连续 ARQ 协议才能正确运行 。窗口单位是分组。](#5-19试证明-当用-n-比特进行分组的编号时若接收窗口等于-1-即只能按序接收分组则仅在发送窗口不超过-2n--i-时连续-arq-协议才能正确运行-窗口单位是分组)
- [【5-21 】假定使用连续ARQ协议，发送窗口大小是3,而序号范围是[O,15),而传输媒体保证在接收方能够按序收到分组。在某一时刻，在接收方，下一个期望收到的序号是5。试问:](#5-21-假定使用连续arq协议发送窗口大小是3而序号范围是o15而传输媒体保证在接收方能够按序收到分组在某一时刻在接收方下一个期望收到的序号是5试问)
- [【5-22】 主机A向主机B发送一个很长的文件，其长度为L字节。假定TCP使用的MSS 为 1460字节。](#5-22-主机a向主机b发送一个很长的文件其长度为l字节假定tcp使用的mss-为-1460字节)
- [【5-23】 主机A向主机B连续发送了两个TCP报文段，其序号分别是70和100。](#5-23-主机a向主机b连续发送了两个tcp报文段其序号分别是70和100)
- [【5-24】 一个 TCP 连接下面使用 256 kbit/s 的链路，其端到端时延为 128 ms。经测试， 发现吞吐量只有 120 kbit/s。试问发送窗口 W 是多少? (提示:可以有两种答 案，取决于接收端发出确认的时机。)](#5-24-一个-tcp-连接下面使用-256-kbits-的链路其端到端时延为-128-ms经测试-发现吞吐量只有-120-kbits试问发送窗口-w-是多少-提示可以有两种答-案取决于接收端发出确认的时机)
- [【5-25】为什么在 TCP 首部中要把 TCP 的端口号放入最开始的 4 个字节?](#5-25为什么在-tcp-首部中要把-tcp-的端口号放入最开始的-4-个字节)
- [【5-26】为什么在 TCP首部中有一个首部长度字段，而 UDP的首部中就没有这个字段?](#5-26为什么在-tcp首部中有一个首部长度字段而-udp的首部中就没有这个字段)
- [【5-27】 一个 TCP 报文段的数据部分最多为多少个字节?为什么?如果用户要传送的数据的字节长度，超过 TCP 报文段中的序号字段可能编出的最大序号，问还能否用 TCP 来传送?](#5-27-一个-tcp-报文段的数据部分最多为多少个字节为什么如果用户要传送的数据的字节长度超过-tcp-报文段中的序号字段可能编出的最大序号问还能否用-tcp-来传送)
- [<5-28 > 主机 A 向主机 B 发送 TCP 报文段，首部中的源端口是 m 而目的端口是 n。 当 B 向 A 发送回信时，其 TCP 报文段的首部中的源端口和目的端口分别是什么?](#5-28--主机-a-向主机-b-发送-tcp-报文段首部中的源端口是-m-而目的端口是-n-当-b-向-a-发送回信时其-tcp-报文段的首部中的源端口和目的端口分别是什么)
- [<5-29 > 在使用 TCP 传送数据时，如果有一个确认报文段丢失了，也不一定会引起与 该确认报文段对应的数据的重传。试说明理由。](#5-29--在使用-tcp-传送数据时如果有一个确认报文段丢失了也不一定会引起与-该确认报文段对应的数据的重传试说明理由)
- [<5-30 > 设 TCP 使用的最大窗口为 65535 字节，而传输信道不产生差错，带宽也不受限制。若报文段的平均往返时间为 20 ms, 问所能得到的最大吞吐量是多少?](#5-30--设-tcp-使用的最大窗口为-65535-字节而传输信道不产生差错带宽也不受限制若报文段的平均往返时间为-20-ms-问所能得到的最大吞吐量是多少)
- [<5-31 > 通信信道带宽为 1 Gbit/s, 端到端传播时延为 10 ms。 TCP 的发送窗口为 65535 字节。试间:可能达到的最大吞吐量是多少?信道的利用率是多少?](#5-31--通信信道带宽为-1-gbits-端到端传播时延为-10-ms-tcp-的发送窗口为-65535-字节试间可能达到的最大吞吐量是多少信道的利用率是多少)
- [【5-32】什么是 Kam 算法?在 TCP 的重传机制中，若不采用 Kam 算法，而是在收到确认时都认为是对重传报文段的确认，那么由此得出的往返时间样本和重传时间都会偏小。试问:重传时间最后会减小到什么程度?](#5-32什么是-kam-算法在-tcp-的重传机制中若不采用-kam-算法而是在收到确认时都认为是对重传报文段的确认那么由此得出的往返时间样本和重传时间都会偏小试问重传时间最后会减小到什么程度)
- [<5-33 > 假定 TCP 在开始建立连接时，发送方设定超时重传时间 RTO == 6 秒。](#5-33--假定-tcp-在开始建立连接时发送方设定超时重传时间-rto--6-秒)
- [<5-34 >已知第一次测得 TCP 的往返时间 RTT 是 30ms。接着收到了三个确认报文段， 用它们测量出的往返时间样本 RTT 分别是: 26 ms, 32 ms 和 24 ms。设a=O.l 。 试计算每一次的新的加权平均往返时间值 RTTs。讨论所得出的结果。](#5-34-已知第一次测得-tcp-的往返时间-rtt-是-30ms接着收到了三个确认报文段-用它们测量出的往返时间样本-rtt-分别是-26-ms-32-ms-和-24-ms设aol--试计算每一次的新的加权平均往返时间值-rtts讨论所得出的结果)
- [【5-35】试计算 一个包 括五段链路的运输连接的单程端到端时延。 五段链路中有两段是 卫星链路，有 三段是广 域网链路 。 每条卫星链路又由上行链路和 下行链路两部 分组成。可以取这两部分的传播时延之和为 250 ms。每一个广 域网的范围为 1500 km, 其传播时延可按 150000 km/s 来计算。各数据链路速率为 48 kbit/s, 帧长为 960 位。](#5-35试计算-一个包-括五段链路的运输连接的单程端到端时延-五段链路中有两段是-卫星链路有-三段是广-域网链路--每条卫星链路又由上行链路和-下行链路两部-分组成可以取这两部分的传播时延之和为-250-ms每一个广-域网的范围为-1500-km-其传播时延可按-150000-kms-来计算各数据链路速率为-48-kbits-帧长为-960-位)
- [【5-37】在 TCP 的拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法?这里 每 一 种算法各起什么作用?“乘法减小”和“加法增大“各用在什么情况下?](#5-37在-tcp-的拥塞控制中什么是慢开始拥塞避免快重传和快恢复算法这里-每-一-种算法各起什么作用乘法减小和加法增大各用在什么情况下)
- [【5-38】设 TCP 的 ssthresh 的初始值为 8 (单位为报文段)。当拥塞窗口上升到 12 时网 络发生了超时， TCP 使用慢开始和拥塞避免。试分别求出第 1 轮次到第 15 轮 次传输的各拥塞窗口大小。你能说明拥塞窗口每一次变化的原因吗?](#5-38设-tcp-的-ssthresh-的初始值为-8-单位为报文段当拥塞窗口上升到-12-时网-络发生了超时-tcp-使用慢开始和拥塞避免试分别求出第-1-轮次到第-15-轮-次传输的各拥塞窗口大小你能说明拥塞窗口每一次变化的原因吗)
- [【5-40】 TCP 在进行流量控制时，是以分组的丢失作为产生拥塞的标志 。 有没有不是因 拥塞而引起分组丢失的情况?如有，请举出 三种情况 。](#5-40-tcp-在进行流量控制时是以分组的丢失作为产生拥塞的标志--有没有不是因-拥塞而引起分组丢失的情况如有请举出-三种情况-)
- [【5-41 】用 TCP 传送 512 字 节的数据。设窗口为 100 字节，而 TCP 报文段每次也是传 送 100 字节的数据 。 再设发送方和接收方的起始序号分别选为 100 和 200, 试 画出类似于教材图 5-28 的工作示意图。从连接建立阶段到连接释放都要画上。](#5-41-用-tcp-传送-512-字-节的数据设窗口为-100-字节而-tcp-报文段每次也是传-送-100-字节的数据--再设发送方和接收方的起始序号分别选为-100-和-200-试-画出类似于教材图-5-28-的工作示意图从连接建立阶段到连接释放都要画上)
- [【5-42】在教材的图 5-29 中所示的连接释放过程中，在 ESTABLISHED 状态下， B 能否 先不发送 ack = u + I 的确认?(因为 B 在后面要发送的连接释放报文段中，仍 有ack=u+I 这一信息。)](#5-42在教材的图-5-29-中所示的连接释放过程中在-established-状态下-b-能否-先不发送-ack--u--i-的确认因为-b-在后面要发送的连接释放报文段中仍-有ackui-这一信息)
- [【5-43】在教材的图 5-30 中，在什么情况下会发生从状态 SYN-SENT 到状态 SYN-RCVD的变迁?](#5-43在教材的图-5-30-中在什么情况下会发生从状态-syn-sent-到状态-syn-rcvd的变迁)
- [【5-44】试以具体例子说明为什么一个运输连接可以有多种方式释放。可 以设两个互相通信的用户分别连接在网络的两结点上。](#5-44试以具体例子说明为什么一个运输连接可以有多种方式释放可-以设两个互相通信的用户分别连接在网络的两结点上)
- [【5-45】解释为什么突然释放运输连接就可能会丢失用户数据，而使用 TCP 的连接释放方法就可保证不丢失数据 。](#5-45解释为什么突然释放运输连接就可能会丢失用户数据而使用-tcp-的连接释放方法就可保证不丢失数据-)
- [【5-46】 试用具体例子说明为什么在运输连接建立时要使用三报文握手 。 做可能会出现什么情况。](#5-46-试用具体例子说明为什么在运输连接建立时要使用三报文握手--做可能会出现什么情况)
- [【5-47】 一客户向服务器请求建立 TCP 连接。客户在 TCP 连接建立的三报文握手中的 最后一个报文段中捎带上 一些 数据，请求服务器发送一个长度为 L 字节的文件。 假定:](#5-47-一客户向服务器请求建立-tcp-连接客户在-tcp-连接建立的三报文握手中的-最后一个报文段中捎带上-一些-数据请求服务器发送一个长度为-l-字节的文件-假定)
- [<5-48 > 网络允许的最大报又段长度为 128 字节，序号用 8 位表示，报文段在网络中的 寿命为 30 秒。求发送报文段的一方所能达到的最高数据率。](#5-48--网络允许的最大报又段长度为-128-字节序号用-8-位表示报文段在网络中的-寿命为-30-秒求发送报文段的一方所能达到的最高数据率)
- [<5-49> 下面是以十六进制格式存储的一个 UDP 首部: CB84000D001COO1C](#5-49-下面是以十六进制格式存储的一个-udp-首部-cb84000d001coo1c)
- [<5-50 > 把教材上的图 5-7 计算 UDP 检验和的例子自已具体演算一下，看是否能够得出书上的计算结果。](#5-50--把教材上的图-5-7-计算-udp-检验和的例子自已具体演算一下看是否能够得出书上的计算结果)
- [<5-51 > 在以下几种情况下， UDP 的检验和在发送时的数值分别是多少? (1) 发送方决定不使用检验和 。(2) 发送方使用检验和，检验和的数值是全 1 。(3) 发送方使用检验和，检验和的数值是全 0。](#5-51--在以下几种情况下-udp-的检验和在发送时的数值分别是多少-1-发送方决定不使用检验和-2-发送方使用检验和检验和的数值是全-1-3-发送方使用检验和检验和的数值是全-0)
- [<5-52> UDP 和 IP 的不可靠程度是否相同?请加以解释 。](#5-52-udp-和-ip-的不可靠程度是否相同请加以解释-)
- [<5-53 > UDP 用户数据报的最小长度是多少?用最小长度的 UDP HJ 户数据报构成的最 短 IP 数据报的长度是多少?](#5-53--udp-用户数据报的最小长度是多少用最小长度的-udp-hj-户数据报构成的最-短-ip-数据报的长度是多少)
- [<5-54 > 某客户使用 UDP 将数据发送给一服务器，数据共 16 字节。试计算在运输层的 传输效率(有用字节与总字节之比)。](#5-54--某客户使用-udp-将数据发送给一服务器数据共-16-字节试计算在运输层的-传输效率有用字节与总字节之比)
- [<5-55 > 重做习题 5-54, 但在 IP 层计算传输效率。假定 IP 首部无选项。](#5-55--重做习题-5-54-但在-ip-层计算传输效率假定-ip-首部无选项)
- [<5-56 > 重做习题 5-54, 但在数据链路层计算传输效率。假定 IP 首部无选项，在数据链路层使用以太网。](#5-56--重做习题-5-54-但在数据链路层计算传输效率假定-ip-首部无选项在数据链路层使用以太网)
- [<5-57 > 某客户有 67000 字节的分组。试说明怎样使用 UDP 数据报将这个分组进行传送。](#5-57--某客户有-67000-字节的分组试说明怎样使用-udp-数据报将这个分组进行传送)
- [【5-58】 TCP 在 4:30:20 发送了一个报文段。它没有收到确认 。在 4:30:25 它重传了前面这个报文段。它在 4:30:27 收到确认。若以前的 RTT 值是 4 秒，根据 Kam 算法，新的 RTT 值是多少?](#5-58-tcp-在-43020-发送了一个报文段它没有收到确认-在-43025-它重传了前面这个报文段它在-43027-收到确认若以前的-rtt-值是-4-秒根据-kam-算法新的-rtt-值是多少)
- [<5-59 > TCP 迕接使用 1000 字节的窗口值，而上一次的确认号是 22001 。它收到了一个报义段 ，确认了宁节 22401。试用图来说明在这之前与之后的窗口情况。](#5-59--tcp-迕接使用-1000-字节的窗口值而上一次的确认号是-22001-它收到了一个报义段-确认了宁节-22401试用图来说明在这之前与之后的窗口情况)
- [<5-60 > 同上题。但接收方收到确认字节为 22401 的报文段时，其窗口字段变变为 1200字节。试用图来说明在这之前与之后的窗口情况。](#5-60--同上题但接收方收到确认字节为-22401-的报文段时其窗口字段变变为-1200字节试用图来说明在这之前与之后的窗口情况)
- [<5-61 > 在本题中列出的 8 种情况下，画出发送窗口的变化，并标明可用窗口的位置。](#5-61--在本题中列出的-8-种情况下画出发送窗口的变化并标明可用窗口的位置)
- [<5-62 > TCP 连接处千 ESTABLISHED 状态 。 以下的事件相继发生:](#5-62--tcp-连接处千-established-状态--以下的事件相继发生)
- [<5-63> TCP 连接处于 SYN-RCVD 状态。以下的事件相继发生:](#5-63-tcp-连接处于-syn-rcvd-状态以下的事件相继发生)
- [<5-64 >TCP 连接处千 FIN-WAIT-I 状态。以下的事件相继发生:](#5-64-tcp-连接处千-fin-wait-i-状态以下的事件相继发生)
- [<5-65 > 假定主机 A 向 B 发送一个 TCP 报文段。在这个报文段中，序号是 50, 而数据一共有 6 字节长。试问，在这个报文段中的确认字段是否应当写入 56?](#5-65--假定主机-a-向-b-发送一个-tcp-报文段在这个报文段中序号是-50-而数据一共有-6-字节长试问在这个报文段中的确认字段是否应当写入-56)
- [<5-66 > 主机 A 通过 TCP 连接向 B 发送 一个很长的文件，因此这需要分成很多个报文 段来发送。假定某一个TCP报文段的序号是X, 那么下一个报文段的序号是否 就是 x+I 呢?](#5-66--主机-a-通过-tcp-连接向-b-发送-一个很长的文件因此这需要分成很多个报文-段来发送假定某一个tcp报文段的序号是x-那么下一个报文段的序号是否-就是-xi-呢)
- [<5-67 > TCP 的吞吐量应当是每秒发送的数据字节数，还是每秒发送的首部和数据之和的字节数?吞吐量应当是每秒发送的字节数，还是每秒发送的比特数?](#5-67--tcp-的吞吐量应当是每秒发送的数据字节数还是每秒发送的首部和数据之和的字节数吞吐量应当是每秒发送的字节数还是每秒发送的比特数)
- [<5-68> 在 TCP 的连接建立的三报文握手过程中，为什么第三个报文段不需要对方的确认?这会不会出现问题?](#5-68-在-tcp-的连接建立的三报文握手过程中为什么第三个报文段不需要对方的确认这会不会出现问题)
- [<5-69 > 现在假定使用类似 TCP 的协议(即使用滑动窗口可靠传送字节流)，数据传输速率是 l Gbit/s, 而网络的往返时间 RTT = 140 ms。假定报文段的最大生存时间是 60 秒。如果要尽可能快地传送数据，在我们的通信协议的首部中，发送窗口和序号字段至少各应当设为多大?](#5-69--现在假定使用类似-tcp-的协议即使用滑动窗口可靠传送字节流数据传输速率是-l-gbits-而网络的往返时间-rtt--140-ms假定报文段的最大生存时间是-60-秒如果要尽可能快地传送数据在我们的通信协议的首部中发送窗口和序号字段至少各应当设为多大)
- [<5-70> 假定用TCP协议在40Gbit/s的线路上传送数据。](#5-70-假定用tcp协议在40gbits的线路上传送数据)
- [<5-71 > 在教材上 5.5 节中指出:例如，若用 2.5Gbit/s 的速率发送报文段，则不到 14 秒钟序号就会重复。请计算验证这句话 。](#5-71--在教材上-55-节中指出例如若用-25gbits-的速率发送报文段则不到-14-秒钟序号就会重复请计算验证这句话-)
- [【5-72】已知 TCP 的接收窗口大小是 600 (单位是字节，为简单起见以后就省略了单位)， 已经确认了的序号是 300。试问，在不断地接收报文段和发送确认报文段的过程 中，接收窗口也可能会发生变化(增大或缩小)。请用具体例子(指出接收方发](#5-72已知-tcp-的接收窗口大小是-600-单位是字节为简单起见以后就省略了单位-已经确认了的序号是-300试问在不断地接收报文段和发送确认报文段的过程-中接收窗口也可能会发生变化增大或缩小请用具体例子指出接收方发)
- [【5-73】在上题中，如果接收方突然因某种原因不能够再接收数据了，可以立即向发送方发送把接收窗口置为零的报文段(即rwnd=0)。这时会导致接收窗口的前沿后退。试问这种情况是否允许?](#5-73在上题中如果接收方突然因某种原因不能够再接收数据了可以立即向发送方发送把接收窗口置为零的报文段即rwnd0这时会导致接收窗口的前沿后退试问这种情况是否允许)
- [<5-74 > 流量控制和拥塞控制的最主要的区别是什么?发送窗口的大小取决千流量控 制还是拥塞控制?](#5-74--流量控制和拥塞控制的最主要的区别是什么发送窗口的大小取决千流量控-制还是拥塞控制)
- [*【5-75】假定在 TCP 连接中刚刚收到的最新的往返时间 RTT 是 1 秒，那么超时重传时间 RTO 是否应当设置成大于或等千 1 秒?](#5-75假定在-tcp-连接中刚刚收到的最新的往返时间-rtt-是-1-秒那么超时重传时间-rto-是否应当设置成大于或等千-1-秒)
- [*< 5-76 >在教材附录 C[KUR013]中的运输层这一章给出了 TCP 连接的平均吞吐量 R 的 公式如下:R= 0.75 W / RTT 这里的RTT是往返时间， W是发生报文段丢失时的拥塞窗口值。 试推导上面的公式，并给出必要的假设条件。这里的吞吐量指的是每秒发送的数据字节(不包括首部)。](#-5-76-在教材附录-ckur013中的运输层这一章给出了-tcp-连接的平均吞吐量-r-的-公式如下r-075-w--rtt-这里的rtt是往返时间-w是发生报文段丢失时的拥塞窗口值-试推导上面的公式并给出必要的假设条件这里的吞吐量指的是每秒发送的数据字节不包括首部)
- [*< 5-79 > TCP 对拥塞控制采用的是动态调整的策略 。能否给出动态调整的要点?](#-5-79--tcp-对拥塞控制采用的是动态调整的策略-能否给出动态调整的要点)
- [<5-80 > 请用框图的表示方法来说明 TCP 的拥寒控制流程。](#5-80--请用框图的表示方法来说明-tcp-的拥寒控制流程)
### 问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?
解答:这个问题很重要，一定要弄清楚。
TCP 是面向连接的，但TCP所使用的网络则可以是面向连接的(如X.25网络)，但也可以是无连接的(如现在大量使用的IP网络)。选择无连接网络就使得整个系统非常灵活，当然也带来了一些问题。
显然，TCP提供的功能和服务要比IP所能提供的多得多。这是因为TCP使用了诸如确认、窗口通知计时器笘机制，因而可以检测出有差错的报文、重复的报文和失序的报文。

### 问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?
解答: 
进程A和进程B的通信是使用面向连接的TCP提供的可靠的传输。
主机X和主机Y的通信是使用无连接的IP提供的不可靠的传输。
请注意:对TCP来说，通信的起点和终点是运输层上面的两个**套接字(socket)**,而应用层的应用进程正是通过应用层和运输层之间的套接字来使用TCP提供的服务。TCP协议根据报文段首部中的端口号找到目的端口，将报文段交付**目的进程**。请注意:套接字是由IP地址和端口号决定的，套接字也可称为“插口”。
对IP来说，通信的起点和终点是连接在网络上的两个**主机**。IP协议根据数据报首部中的目的IP地址找到目的主机，将数据报交付**目的主机**。
请注意可靠传输的范围和不可靠传输的范围是不同的 。
我们还应当注意的是:虽然在两个套接字之间的通信是面向连接的，但IP数据报在下面的网络中传输时是独立地选择路由，而**不是沿着某—条固定的路径传输**。然而在上面的端口看来，TCP报文段**好像都是从一个虚拟的、可靠的通信管道中传输到对方的端口的。**

### 问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么? 
解答: IP是**主机到主机**的通信协议，但UDP是**进程到进程**的通信协议。

### 问题 5-4. 端口(port)和套接字(socket)的区别是什么?
解答: 从教材经常使用的套接字定义来看，套接字包含了端口，因为**套接字**=(IP地址，端口号)。套接字是TCP连接的端点。套接字又称为"插口”。
但我们已经讲过，套接字(socket)有多种意思。当使用API时，套接字往往被看成是操作系统的一种抽象，这时，套接字和一个文件描述符是很相似的，并且是应用编程接口API的一部分。套接字由应用程序产生，并指明它将由客户还是服务器来使用。当应用进程创建一个套接字时，要指明该套接字使用的瑞门号。
**端口**则是应用层服务的一种代号，它用来标志应用层的进程。端口是一个16bit的整数。各种服务器使用的湍口号都是保留端口号，以便使客户能够找到服务器。例如万维网服务器使用的端口号是80。
在发送数据时，应用层的数据通过端口向下交付运输层。在接收数据时，运输层的数据通过适当的端口向上交付应用层的某个应用程序。

### 问题 5-5 一 个套接字能否同时与远地的两个套接字相连?
解答:不行。一个套接字只能和另一个远地套接字相连。
如果许多个客户同时访问同一个服务器，那么对千这种情况，请参考教材第6章图6~30及相应的文字解释。

### 问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?
解答:运输层的TCP协议是端到端(进程到进程)的协议，而数据链路层的HDLC协议则是仅在一段链路上的结点到结点的协议。此外，TCP的窗口机制和HDLC的也有许多区别。如TCP是按数据部分的字节数进行确认的，而HDLC则是以帧为确认的单位。需要注意的是，现在使用得最多的PPP链路层协议并不使用确认机制和窗口机制。因此像PPP协议这样的链路层协议就和运输层协议有相当大的区别 。

### 问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?
解答:在旧的OSI体系中，在数据链路层使用HDLC协议而在网络层使用X.25协议，这些协议都有确认机制和窗口机制，因而能够保证可靠传输。但是技术的进步使得链路的传输已经相当可靠了，因此在数据链路层和网络层重复地保证可靠传输就显得多余了。现在互联网在链路层使用的PPP协议和在网络层使用的IP协议都没有确认机制和窗口机制。如果出现差错就由运输层的TCP来处理(若使用UDP协议则运输层也不处理出错的问题)。

### 问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?
解答:显然，仅从TCP报文段的首部无法得知目的IP地址。因此，TCP必须告诉IP层此报文段要发送给哪一个目的主机(给出其IP地址)。此目的IP地址填写在IP数据报的首部中。

### 问题5-9在TCP传送数据时，有没有规定一个最大重传次数?
解答:我们知道以太网规定重传16次就认为传输失败，然后报告上层。但TCP没有规定最大重传次数，而是通过设置一些计时器来解决有关传输失败的问题。

### 问题5-10.TCP都使用哪些计时器?
解答:TCP共使用以下四种计时器，即重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下。
**重传计时器**
当 TCP 发送报文段时，就创建该特定报文段的重传计时器。可能发生两种情况:
(I) 若在计时器截止时间到来之前收到了对此特定报文段的确认，则撤销此计时器。
(2) 若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。
**持续计时器**
为了对付零窗口大小通知， TCP 需要另 一个计 时器。假定“接收 TCP" 给出了窗口大小 为零，“发送 TCP"就停止传送报文段，直到“接收TCP"发送确认并给出一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认报文段是不发送确认的。若确认丢失了，“接收TCP"并不知道，而是会认为它已经完成任务了，并等待着“发送TCP"接着会发送更多的报文段。但“发送TCP"由千没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。
要打开这种死锁，TCP为每一个连接使用一个待续计时器。当“发送TCP"收到一个窗口大小为零的确认时，就启动持续计时器。当持续计时器期限到时，“发送TCP"就发送一个特殊的报文段，叫做探测报文段。这个报文段只有一个字节的数据。它有一个序号，但它的序号永远不需要确认;甚至在计算对其他部分的数据的确认时，该序号也被忽略。探测报文段提醒接收TCP:确认已丢失，必须重传。
待续计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将待续计时器的值加倍和复位。发送端继续发送探测报文段，将持续计时器设定的值加倍和复位，直到这个值增大到门限值(通常是60秒)为止。在这以后，发送端每隔 60 秒就发送一个探测报文段，直到窗口重新打开。
**保活计时器**
保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保待静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处千打开状态。
要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段(每一个相隔75秒)还没有响应，就假定客户出了故障，这时就终止该连接。
**时间等待计时器**
时间等待计时器是在连接终止期间使用的。当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间，连接还处千一种中间过渡状态。这就可以使重复的FINC终止)报文段(如果有的话)可以到达目的站，从而可将其丢弃。这个计时器的值通常设置为一个报文段的寿命期待值的两倍。


### 问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?
解答:往返时间RTT只是对运输层的TCP协议才很重要，因为TCP要根据平均往返时间RTT的值来设置超时计时器的超时时间。
UDP没有确认和重传机制，因此RTT对UDP没有什么意义。
所以，不要笼统地说“往返时间RTT对运输层来说很重要“，因为只有TCP才需要计算RTT,而UDP不需要计算RTT。

### 问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?
解答:这时TCP显然无法利用已有的公式算出往返时间RTT。实际上TCP是选择(也就是猜测)一个比较长的时间作为初始的往返时间RTT。等到收到至少一个确认报文段时，才能利用公式计算出比较合理的往返时间 RTT。

### 问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?
解答: 糊涂窗口综合征产生的条件是: 当发送应用程序产生数据很慢，或接收应用程序读取数据(或消耗数据)很慢，或者两者都有。这时发送方和接收方都可能产生这种症状。
不管是上述情况中的哪一种，都使得发送数据的报文段很小，这就引起操作效率的降低。例如，若TCP发送的报文段只包括一个字节的数据，则意味着我们发送41字节的数据报(20字节的TCP首部和20字节的IP首部)才传送1字节的数据。数据的传送效率是1/41,它表示我们在非常低效率地使用网络的容量。

### 问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?
解答 :详细讨论如下。
**发送端产生的症状**
如果发送端为产生数据很慢的应用程序服务，例如，一次产生一个字节。这个应用程序一次将一个字节的数据写入发送端的TCP的缓存。如果发送端的TCP没有特定的指令，它就产生只包括一个字节数据的报文段。结果有很多41字节的IP数据报就在互联网中传来传去。
解决的方法是防止发送端的TCP逐个字节地发送数据。必须强迫发送端的TCP收集数据，然后用一个更大的数据块来发送。发送端的TCP要等待多长时间呢?如果等待时间过长，它就会使整个过程产生较长的时延。如果等待时间不够长，它就可能发送较小的报文段。Nagle找到了一个很好的解决方法。
**Nagle算法**
Nagle算法非常简单，但它能解决问题。这个算法是为发送端的TCP用的:
(I)发送端的TCP将它从发送应用程序收到的第一块数据发送出去，哪怕只有一个字节。(2)在发送第一个报文段(即报文段I)以后，发送端的TCP就在输出缓存中积累数据，
并等待:或者接收端的TCP发送出一个确认，或者数据已积累到可以装成一个最大的报文段，在这个时候，发送端的TCP就可以发送这个报文段。
(3)对剩下的传输，重复步骤2。这就是:如果收到了对报文段x的确认，或者数据已积累到可以装成一个最大的报文段时，那么就发送下一个报文段(x+1)。
Nagle算法的优点就是简单，并且它考虑到应用程序产生数据的速率，以及网络运输数据的速率。若应用程序比网络更快，则报文段就更大(最大报文段)。若应用程序比网络慢，则报文段就较小(小于最大报文段)。
**接收端产生的症状**
接收端的TCP可能产生糊涂窗口综合征，如果它为消耗数据很慢的应用程序服务，例如，一次消耗一个字节。假定发送应用程序产生了1000字节的数据块，但接收应用程序每次只读取1字节的数据。再假定接收端的TCP的输入缓存为4000字节。发送端先发送第一个4000字节的数据。接收端将它存储在其缓存中。现在缓存满了。接收端的TCP就通知窗口大小为零，这表示发送端必须停止发送数据。接收应用程序从接收端的TCP的输入缓存中读取第一个字节的数据。这时在输入缓存中就有了1字节的空间。接收端的TCP宣布其窗口大小为1字节，这表示正渴望等待发送数据的发送端的TCP会把这个宣布当作一个好消息，并发送只包括一个字节数据的报文段。这样的过程一直继续下去。一个字节的数据被消耗掉，然后再发送只包含一个字节数据的报文段。这又是一个低效率问题和糊涂窗口综合征(见图Q-5-14)
对于这种糊涂窗口综合征，即应用程序消耗数据比到达的慢，有两种建议的解决}」法。
**Clark解决方法**
Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，自到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。
**延迟的确认**
第二个解决方法是延迟一段时间后再发送确认。这表示当一个报文段到达时并不立即发送确认。接收端在确认收到报文段之前一直等待，直到缓存有足够的空间为止。延迟的确认防止了发送端的TCP滑动其窗口。当发送端的TCP发送完其数据后，它就停下来了。这样就防止了这种糊涂窗口综合征。
迟延的确认还有另一个优点:它减少了通信量。接收端不需要确认每一个报文段。但它也有一个缺点，就是迟延的确认有可能迫使发送端重传其未被确认的报文段。
可以用协议来平衡这个优点和缺点，例如，现在定义了确认的延迟不能超过500毫秒。

### 问题 5-15 为什么TCP什让汒连接盯小能每次都选择相同的、固定的初始序号?
解答:如果TCP在建立连接时每次都选择相同的、固定的初始序号，那么设想以下的情况:
(1)假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。
(2)假定每一次建立连接时，主机A都选择相同的、固定的初始序号，例如，选择l。
(3)假定主机A发送出的某些TCP报文段在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段。
(4)假定有一些在网络中滞留时间较长的TCP报文段最后终于到达了主机B,但这时传送该报文段的那个连接早已释放了，而在到达主机B时的TCP连接是一条新的TCP连接。这样，工作在新的TCP连接下的主机B就有可能会接受在旧的连接传送的、已经没有意义的、过时的TCP报文段(因为这个TCP报文段的序号有可能正好处在现在新的连接所使用的序号范围之中)，结果产生错误。
因此，必须使得迟到的TCP报文段的序号不处在新的连接中所使用的序号范围之中。
这样，TCP在建立新的连接时所选择的初始序号，一定要和前面的一些连接所使用过的序号不一样。所以，不同的TCP连接不能使用相同的初始序号。

### 问题 5-16. 能否利用 TCP 发送端和接收端交换报文段的图来说明慢开始的特点? 
解答:慢开始的特点可以用图 Q-5-16 来说明。
拥塞窗口cwnd的初始值是1(为方便起见，这里将拥塞窗口的单位设为报文段)。以后**每收到一个对新的报文段的确认，就将发送端的拥塞窗口cwnd加1。**
从图Q-5-16可以看出，拥塞窗口cwnd按照指数规律增长。所谓“新的报文段”就是指“未被确认过的报文段"。由千报文段在互联网中传输时，有可能在某个路由器处滞留一段时间，但以后又被交付接收端(重复交付)。接收端对每一个收到的无差错的报文段都可能给出确认。因此，对同一个报文段，发送端有可能收到几个重复的确认。但除了第一个确认可以使发送端拥塞窗口cwnd加1以外，对其余重复的报文段的确认都不能再使发送端拥塞窗口加1。


### 问题 5-17. 对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理?
解答:可以，但这只能是示意图。
因为在拥塞避免的开始，发送端的拥塞窗口 swnd=ssthresh,这时可以发送好几个报文段。 按照 RFC 2581 文档，每经过一个往返时间 RTT, 拥塞窗口就增加一个 MSS (最大报文段长 度)的大小(以字节为单位)。
在我们讨论原理时，以报文段个数作为窗口单位较为方便，因此在图 Q-5-17 中每经过一 个 RTT, 发送端拥塞窗口 swnd 就在 ssthresh 的基础上加1。
在图 Q-5-17 中将发送端发送报文段用一个粗箭头表示(因为这里面包含有许多个报文段， 很难一个个画出)，确认报文段也用一个粗箭头表示(这也可能有许多个确认报文段)，因此RTT也是概念性的往返时间。

### 问题 5-18. TCP连接很像一条连接发送端和接收端的双向管道。当 TCP在连续发送报文段时，若要管道得到充分的利用，则发送窗口的大小应怎样选择?
管道空间是有限的。当发送窗口很小时，管道在大部分时间内是比较空的,这说明在TCP连接中传输数据的效率比较低。当发送窗口增大时，管道逐渐被填满。发送管道一直是被填满的，这说明发送管道被利用得很充分。因为报文段的传输需要时间，因此对报文段的确认总是会滞后一段时间。
在单方向发送报文段(另一个方向发送确认)的情况下，发送管道和接收管道往往不能同时被充分利用(除非发送窗口的数值较大)。但如果双向都能发送数据报文段，那么发送管道和接收管道就都能够被利用得较充分。
我们还可看出，接收管道(即接收端发送确认报文段的管道)在任何情况下都没有填满。这是因为确认报文段很短，只需很短的时间就可发送出去。但接收一个数据报文段需要较多的时间，这就造成确认报文段不可能连续地从接收瑞发送出去。


### 问题5-19. 假定在一个互联网中，所有的链路的传输都不出现差错，所有的结点也都不会发生故障。试间在这种情况下， TCP 的”可靠交付"的功能是否就是多余的?
 解答:不是多余的。TCP的”可靠交付”功能在互联网中起着至关重要的作用。至少在以下所列举的情况下，TCP的”可靠交付”功能是必不可少的。
(I)每个IP数据报独立地选择路由，因此在到达目的主机时有可能出现失序。
(2)由千路由选择的计算出现错误，导致IP数据报在互联网中兜圈子。最后数据报首部中的生存时间TTL的数值下降到零。这个数据报在中途就被丢弃了。
(3)在某个路由器突然出现很大的通信量，以致路由器来不及处理到达的数据报。因此有的数据报被丢弃。
以上列举的问题表明了:必须依靠TCP的”可靠交付”功能才能保证在目的主机的目的进程接收到正确的报文。


### 问题5-20. TCP是通信协议还是软件?
解答:协议与实现协议的软件之间的区别，类似千编程语言的定义与编译器之 间的区别 。与编程语言的情况类似，编程语言的定义与编程语言通过编译器在计算机上的实现之间的区别有时也会比较模糊。大家与TCP软件打交道的机会远远比与TCP协议规范打交道的机会要多，因而会很自然地把某个协议的具体实现当作是协议的标准。尽管如此，我们必须明确地区分两者。
总之，TCP是通信协议，而不是一个软件。


### 问题5-21.在计算TCP的往返时间RTT的公式中，《计算机网络》教材过去的版本是取a=7/8。但在第6版和第7版中是取a=1/8。为什么会有这样大的改变?
解答:过去的版本是参考有的国外教材(例如，著名的Comer的《用TCP/IP进行网际互连》的卷1就是这样写的)，这本教材上把RTT的计算公式写为:
平均往返时延RTT=ax(旧的RTT)+(I-a)x(新的往返时延样本)而取a=7/8。
教材第6版和第7版中是考虑到最好和文档RFC6298的写法一致，这样可能会更加便于读者查阅比较权威的RFC文档。现在的RTT计算公式是:
新的RTTs=(l-a)x(旧的RTTs)+ax(新的RTT样本)
而取a=1/8。但这两种不同的写法在实质上并无不同，得出的计算结果是一样的。另外有些改动的地方是:
(1)RTT以前译为“往返时延"，现在改为“往返时间”。这样更加准确一些，因为RTT的后面一个T是Time,应当译为“时间”。以前用的"往返时延”来自"Round-TripDelay"。
(2)以前没有用RTTs这个符号，是为了使符号不要太多。现在看来，多用一个符号可能会更清楚一些(RFC文档也有这个符号，但他们使用的文本文件，不便千用下标，因此他们用的符号是SRTT,表示SmoothedRTT(平滑的RTT)。

### 问题 5-22 假定有一个应用程序需要知道报文从发送端到接收端所经受的时延。能否这样计算:从TCP获得往返时间RTT的数值。然后除以2?
解答:不行。RTT仅仅是TCP内部的数据，上层的应用程序无法从TCP获得RTT的数值。但应用程序可以模仿TCP的做法，即从应用层发送一个报文给对方，等收到确认后，就可算出报文的往返时间。把这个时间除以2,就得出报文从发送端到接收端所经受的时延。

### 问题 5-23. 教材上的图 5-7 在计算 UDP 检 验和时，为什么有的读者算出的“求和得出的 结果”是 1001011011101011, 而不是教材上给出的 10010110 1110110I?
解答:我们在进行二进制反码求和时，必须仔细地把进位加进去。
例如，先把最低位(右边数起的第1列)相加。这里一共有9个1,因此加出来的结果是10012。把1001中的最右面的1写在结果中，在它前面的100是进位。下面的图说明这三个进位应当放在哪一列。进位是l的就要和原来这一列上的数目相加。
再看第2列的相加。第2列一共有7个1,因此得到的和是1,但要有两个进位11。其中的一个l的位置应当是在从右边数起的第3列上，另一个1应当在第4列上。
然后再把第3列的数(包括进位上来的数)相加。
这样加下去，每一次都必须把前面得到的进位考虑进去。这样，一直加到最左边的第16列。
读者自己演算后就可发现，进行最左边的第16列的运算后，在第17列上(这已经超过了16位数的范围)有两个进位1。这两个1相加后的和是102。我们必须把这两个进位拿到最右边，再和刚才得到的、未考虑到最后的进位的初步计算结果相加，这就是“回卷"。刚才得到的计算初步结果是:
10010110 11101011
再加上 10后，得到
100IO110 11101101
这就是教材上给出的正确结果。

### 问题 5-24. TCP 的客户端和服务器端在交换数据时，为什么不含数据的确认报文段不消耗序号呢?
解答:我们知道， TCP把要传送的数据中的每一个字节都编上序号，其目的就是为了保 证每一个数据字节都能正确地传送到对方。接收方按字节的编号对收到的数据进行核对。用发送确认报文段的方法保证能够收到发送方发送的每一个数据字节。
但是，一个有趣的问题来了。纯粹的确认报文段并不带有数据。可是这种确认报文段却仍有序号。之所以出现这个序号，只是因为首部中有这样一个序号字段。我们可以用图Q-5-24来说明这个问题。
在图Q-5-24中，我们假定TCP通信的一方A要发送三个报文段总共发送300字节给B,每个报文段携带100字节的数据。A的报文段#1的序号是1。B收到后发送报文段#2。我们假定B现在的序号是5。A接着发送报文段#3。B发送确认报文段#4,其序号仍然是5。A再发送报文段#5。B发送确认报文段#6,其序号仍然是5。我们假定B现在要用报文段#7发送20个字节的数据给A,这个报文段的序号还是5。
为什么B发送的四个报文段的序号都是5呢?因为B发送的前三个确认报文段都不消耗序号。
但如果B在确认报文段中还带有数据，那么这种确认报文段当然要消耗序号。所消耗的序号数就是这个报文段携带的数据的字节数。
我们可以看出，即使B发送的前三个确认报文段都丢失了，有B的第四个报文段(即报文段#7)的ack=301就够了，A就知道自己所发送的数据，在序号300以前的(包括序号为300的)，B已经都收到了。可见给确认报文段编号是没有必要的。

### 问题 5-25. TCP 在连接建立时所发送的第一个 SYN 报文段只有首部，其数据部分是空的。 但为什么 SYN 报文段要消耗一个序号呢?
解答: TCP 在连接建立时所发送的第 一个 SYN 报文段是 一个控制报文段 ，其主要目的 是为了和对方建立同步，并明确自己采用的初始序号。这个报文段没有数据部分。按理说， 好像这个 SYN 报文段不需要序号。但是 SYN 报文段非常重要，是不允许丢失的(传错了或 丢失了就要重传，否则无法建立连接)，这就必须进行编号。虽然 SYN 报文段没有数据部分， 只有首部，但我们可以想象 SYN 报文段包含有一个虚字节的数据，因此给 SYN 报文段一个 序号，让 SYN 报文段消耗一个序号。当对方收到序号为 x 的 SYN 报文段后，给出的确认就 应当是 ack=x +Io 发送方收到这个确认，就知道发送的 SYN 报文段已正确地传送到对方了。

### 问题 5-26. TCP 在连接建立时，A发送SYN报文段，选择了初始序号seq=x。B收到连接请求报文段后，如同意建立连接，则向A发送确认和SYN报文段，其确认号是ack = x + 1, 同时也为自己选择一个初始序号 seq=y。 A 最后要发送确认报文段， 其序号是 seq= x + 1, 确认号是 ack = y + I 。这个确认 报文段消耗序号吗?
解答题目所说的 TCP连接建立的过程，如图Q-5-26所示。这就是教材上讲的“三报文握手”。
A所发送的确认报文段#3是不消耗序号的。
如果A在确认报文段#3之后接着发送数据报文段，那么这个数据报文段的序号就仍然是seq=x+I,因为确认报文段#3是不消耗序号的。
但是应当注意，如果A所发送的确认报文段#3携带了数据，那么这个报文段就消耗序号。
例如，A所发送的确认报文段#3携带了100字节的数据，那么A下一次发送的数据报文段#4的序号就应当是seq=x + 101。

### 问题 5-27. TCP 连接建立采用的 Three-Way Handshaking 的准确译名应当是怎样的? 
解答:过去很多人(包括本教材)把 Three-Way Handshaking 译为“三次握手”，但这是不准确的。
要建立 TCP 连接，客户端和服务器端的报文段交互的确需要三次，但这三次合起来应当算是一次握手的过程。也就是说，要建立 TCP 连接，需要客户和服务器双方进行一次握手， 但这种“一次“握手需要双方交换三个报文段 CA 到 B, B 到 A, A 再到 B)。现在，也有一 些人采用了“三向握手”这样的译名。但“三向”也有可能被理解为“三个方向“，这就不正确了。
在RFC 793中指出了，这种Three-Way Handshaking也就是“三报文握手”。因此，Three-Way Handshaking 最好是按意思译为“三报文握手”。

### 问题 5-28. TCP 报文段的长度有没有规定的最小值和最大值? 
解答:我们首先必须明确，在谈到 "TCP 报文段的长度”时，可能会有两种不同的理解。 
第一种理解是:这是指 TCP 报文段的总长度(首部和数据部分的长度之和)。 
第二种理解是:这是指 TCP 报文段数据字段的长度(不包括首部的长度)。 
这两种理解都是合理的。从字面上看，很自然会看到第一种理解是合理的。但我们知道，在 TCP 首部中的选项中有一个最大报文段长度 **MSS (Maximum Segment Size)**。这个 MSS 指 的是 TCP 报文段的数据字段的最大长度，并不包括首部。由于 MSS 是 TCP 协议正式使用的 名词，因此第二种理解也是很合理的。
这两种不同的理解有可能产生一些模糊不清的概念 。
为此，每当我们遇到 "TCP报文段长度”时，就应当弄清这里是指 "TCP 报文段的总长度”还是 "TCP报文段数据字段的长度”。
由于这两种长度仅仅相差一个 TCP 报文段的首部，因此在讨论 TCP 报文段长度的最小值和最大值时，可以随便采用上面的一种理解，只要说清楚是哪一种长度即可。
下面在讨论这个问题时，我们会采用很明确的表述方法，使读者不至千感到模糊不清 。
TCP 报文段的总长度显然有 一个最小值，这就是当 TCP 的数据字段的长度为零的情况 。例如，TCP的确认报文段，仅仅有一个固定长度 (20 字节)的首部，其数据字段的长度是零。在这种清况下， TCP 报文段的总长度就是最小值 20 字节。这种 TCP 的首部是没有选项的首部。
TCP 报文段总长度的最大值受以下两个方面的限制:
 (I) IP 数据报的总长度有 一 个规定的最大长度，即 **65535 字节**。如果使用 20 字节的固定长度IP首部，那么TCP报文段的总长度一定不能超过65515字节。如果超过了这个数值，必须在运输层分割报文段，使每一个TCP报文段不超过**65515**字节，否则无法封装成IP数据报。
(2)TCP报文段数据部分的长度不能超过最大报文段长度MSS值。我们知道，在TCP连接建立阶段，每一方要向对方说明自己所能接收的数据长度是多少(因为收到的数据要先存放在TCP的接收缓存中，如果数据太长就会放不下)。有人说，“在TCP的连接建立阶段，双方要协商MSS的数值"。但这种说法是错误的(在RFC879中专门指出这种说法是错误的，因为这里不存在什么协商)。通信的双方只是把自己的接收能力通知对方的TCP而已，并没有协商的过程。双方根据自己当时的具体条件给出的MSS值完全可以是不一样的。因此，TCP报文段的数据部分的长度肯定不能超过对方TCP给出的MSS数值。
这样，我们可以得出下面的表达式:
TCP报文段的总长度 ~Min[(对方给出的 MSS +TCP 首部)， 65515 字节]
这里假定了 IP 数据报使用 20 字节的固定长度 IP 首部。

### 问题 5-29. 能否这样讲:当我们在互联网上传送很长的大文件时，就必须使用 TCP 协议 而不是使用 UDP 协议?
解答 :上面的表述不全面。
当我们通过互联网传送很长的大文件时(例如，作为电子邮件的附件的大文件，或从某 个网站下载一个大文件)，一般都是使用了TCP协议，为的是保证在传送过程中不出现差错。我们都知道，一个大文件，只要在传送过程中间有一小点差错，就会导致整个大文件无法打开，就可以导致整个文件传送失败。因此，这种大文件的传送，几乎都不使用UDP来传送，因为UDP不能保证不出差错。接收端收到有差错的UDP报文段时(检验和不正确)，就简单地丢弃它。
但这也有例外的情况。
假设我们正在计算机上观看一个实时的流视频。这通常是个很长的文件，被分割成很多文件块并实时播送。这些文件块一个接一个地发送出去。如果运输层认为应当重传损坏或丢失的帧，那么整个传输的同步性就会丢失。观看者会突然看到一个空屏，然后需要等到第二次的传输到达。这是无法忍受的。但是，如果每一小块屏幕内容都用一个UDP用户数据报来传送那么接收方UDP就能简单地忽略损坏或丢失的分组，并将其他分组交付应用程序。部分屏幕可能会有非常短暂的空白，这对大多数观看者来说甚至都不会注意到。这就说明，在一些特殊情况下，不保证可靠传输的UDP协议也是很有用的。

### 习题与解答
### 【5-01 】 试说明运输层在协议栈中的地位和作用。运输层的通信和网络层的通信有什么 重要的区别?为什么运输层是必不可少的?
 解答:从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属千面 向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用 网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部 分中的路由器在转发分组时都只用到下三层的功能。
 从网络层来说，通信的两端是两个主机。 IP 数据报的首部明确地标志了这两个主机的 IP 地址。但“两个主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是 在主机中的进程，是这个主机中的 一 个进程和另一个主机中的一个进程在交换数据(即通信)。 因此严格地讲，两个主机进行通信就是两个主机中的应用进程互相通信。 IP 协议虽然能把分 组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运 输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是 应用进程之间的通信(见图 T-5-01)。因此，运输层是不可缺少的。
 所以运输层的通信和网络层的通信有很大的区别 。网络层 提供主机之间的逻辑通信，而 运输层则提供应用进程之间的逻辑通信。
运输层还有**复用、分用**的功能，还要对收到的报文进行**差错检测**。

### <5-02 > 网络层提供数据报或虚电路服务，对上面的运输层有何影响?
解答:网络层提供的两种服务的最大不同就是:数据报不提供可靠的交付，而虚电路服 务则提供可靠的交付。初看起来，似乎是如果网络层提供了可靠的交付，那么运输层就可以 简化一些，就不需要可靠交付了，因而可以简化一些。其实不然。事实证明，**即使网络层提供了可靠的交付，那也只是主机到主机的通信是可靠的，而我们需要的进程到进程的通信仍然可能出错。**因此，当必须保证可靠通信时，不管网络层提供多么可靠的服务，运输层仍然 必须有可靠交付的协议。因此，互联网在网络层只提供比较简单的数据报服务(这样就使得 网络层大大简化，使得网络的造价降低)，而用连接在网络上的主机中的运输层来实现可靠交付。可见对于互联网的设计，网络层的服务并没有对运输层的设计产生多大的影响 。

 ### <5-03 > 当应用程序使用面向连接的 TCP 和无连接的IP时，这种传输是面向连接的还是无连接的?
解答:这要在不同层次来看。在运输层是面向连接的，而在网络层则是无连接的。

### 【5-04】试画图解释运输层的复用。画图说明许多个运输用户复用到 一 条运输连接上， 而这条运输连接又复用到 IP 数据报上。
主机 H3 同时与主机凡和 H2进行通信。凡和 H3 的两个应用进程 (HTTP 和 SMTP) 进行通信，这需要使用两个 TCP 连接。这两个 TCP 连接所传送的报文段，使用下面的网络层的 IP 数据报传送。 H2 和 H3 的应用进程 (HTTP) 进行通信，这需要使用一个 TCP 连接。这个 TCP 连接所传送的报文段，也要使用下面的网络层的 IP 数据报来传送。在 网络层所传送的 IP 数据报己看不到运输层以上的复用情况。

### 【5-05】试举例说明有些应用程序愿意采用不可靠的 UDP, 而不愿意采用可靠的 TCP。 
解答:这可能有以下几种情况。 首先，在互联网上传输实时数据的分组时，有可能会出现差错甚至丢失。如果**利用 TCP协议对这些出错或丢失的分组进行重传，那么时延就会大大增加**。因此，实时数据的传输在运输层就应采用用户数据报协议UDP,而不使用TCP协议。这就是说，对千传送实时数据，我们宁可丢失少量分组(当然不能丢失太多，否则重放的质量就太差了)，也不要等待太晚到达的分组。在连续的音频或视频数据流中，很少量分组的丢失对播放效果的影响并不大(因为这是由人来进行主观评价的)，因而是可以容忍的。在这种情况下，我们愿意采用不可靠的UDP,而不愿意采用可靠的TCP。
其次，当网络出现拥塞时，TCP的拥塞控制就会让TCP的发送方放慢报文段的发送。可能**有的应用程序就不愿意放慢其报文段的发送速度**。另外，可能有的应用程序不需要TCP的可靠传输。在这些清况下，就宁可使用UDP来传送。

### <5-06 > 接收方收到有差错的 UDP 用户数据报时应如何处理? 
 解答:简单地丢弃 。

### <5-07> 如果应用程序愿意使用 UDP 完成可靠传输，这可能吗?请说明理由 。 
解答:这是可能的，但这要由应用层自己来完成可靠传输。例如，应用层自己使用可靠传输协议。当然，这还是需要相当大的工作量的。

### <5-08> 为什么说 UDP 是面向报文的，而 TCP 是面向字节流的?
解答:发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，如教材的图5-4所示。在接收方的UDP,对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了 IP 层的效率。

### <5-09 > 端口的作用是什么?为什么端口号要划分为三种?
解答: 端口是用来标志进程的。端口也就是协议端口号。但这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同 硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的 一种地址 。不同的系统，具体实现端口的方法可以是不同的(取决于系统使用的操作系统)。TCP/IP的运输层用一个16位端口号来标志一个端口。但端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网中不同的计算机中，相同的端口号是没有关联的。
两个计算机中的进程要互相通信，不仅必须知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号(为了找到对方计算机中的应用进程)。
端口号有三种。不同的端口类别有其特殊的用途。例如，客户端是通信的发起方，而服务器是服务的提供方。它们对端口的使用要求是不同的。这三种端口号是:
(I)熟知端口号或系统端口号，数值为0-1023。这些数值可在网址www.iana.org查到。IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。
(2)登记端口号，数值为1024-49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须按照IANA规定的手续登记，以防止重复。
上面两种端口号是服务器端使用的端口号。下面的一种是客户端使用的端口号。
(3)短暂端口号，数值为49152-65535。这类端口号**仅在客户进程运行时才动态选择，是留给客户进程选择暂时使用**。


### <5-10 > 试说明运输层中伪首部的作用 。
解答:所谓“伪首部”是因为这种伪首部并不是UDP用户数据报或TCP报文段真正的首部。只是在计算检验和时，临时添加在UDP用户数据报或TCP报文段的前面，得到—个临时的UDP用户数据报或TCP报文段。检验和就是按照这个临时的UDP用户数据报或TCP报文段来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算运输层的检验和。

### 【5-11 】 某个应用进程使用运输层的用户数据报UDP,然后继续向下交给IP层后，又封装成IP数据报。既然都是数据报，是否可以跳过UDP而直接交给IP层?哪些功能UDP提供了但IP没有提供?
解答:IP数据报只能找到目的主机而无法找到目的进程。如果应用进程直接把数据交给下面的IP层，那么在传送到对方IP层后，就只能交付目的主机，但不知道应当交付哪一个应用进程。**UDP提供对应用进程的复用和分用功能，以及提供对数据部分的差错检验**。这些功能IP层没有提供。

### 【5-12】 一个应用程序用UDP,到了JP层把数据报再划分为4个数据报片发送出去。结果前两个数据报片丢失，后两个到达目的站。过了一段时间应用程序重传UDP,而IP层仍然划分为4个数据报片来传送。结果这次前两个到达目的站而后两个丢失。试问:在目的站能否将这两次传输的4个数据报片组装成为完整的数据报?假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中。
解答:不行。重传时，IP数据报的标识字段会有另一个标识符。**仅当标识符相同的IP数据报片才能组装成一个IP数据报**。前两个IP数据报片的标识符与后两个IP数据报片的标识符不同，因此不能组装成一个IP数据报。

### 【5-13】 一个 UDP 用户数据报的数据字段为 8192 字节。在链路层要使用以太网来传送。 试问应当划分为几个 IP 数据报片?说明每一个 IP 数据报片的数据字段长度和片偏移字段的值。
解答: UDP用户数据报的长度=8192+8=8200B
**以太网数据字段最大长度是 1500 B**。若 IP 首部为 20 B, 则 IP 数据报的数据部分最多只能有 1480 B。 8200 = ]480 X 5 + 800, 因此划分的数据报片共 6 个。 数据字段的长度:前 5 个是 1480 字节，最后一个是 800 字节。 第 1 个数据报片的片偏移字节是 0。
第 2 个数据报片的片偏移字节是 1480 B。
第 3 个数据报片的片偏移字节是 1480 x 2 = 2960 B。 第 4 个数据报 片的片偏移字节是 1480 x 3 =4440 B。 第 5 个数据报片的片偏移字节是 I480 x 4 = 5920 B。 第 6 个数据报片的片偏移字节是 1480 x 5 = 7400 B。

### 【5-14】 一个 UDP 用户数据报的首部的十六进制表示是: 06 32 00 45 00 1C E2 17。试 求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报 是从客户发送给服务器还是从服务器发送给客户?使用 UDP 的这个服务器程序是什么?
解答:把 UDP 首部8个字节的数值写成二进制表示的数值，
源端口 0000011000110010, 其十进制表示是 1024 + 512 + 32 +16 + 2 = 1586。 
目的端口000000000100010I, 其十进制表示是64+4+l=69。
UDP 用户数据报总长度 00000000 00011100 , 其十进制表示是 16 + 8 + 4 = 28 字节。 数据部分长度是 UDP 总长度减去首部长度= 28- 8 = 20 字节。
此UDP用户数据报是从客户发给服务器(因为目的端口号<1023, 是熟知端口)。服务器程序是 TFTP C从教材 5.1.3 节的熟知端口号的表可查出)。

### 【5-15】使用 TCP 对实时话音数据的传输有没有什么问题?使用 UDP 在传送数据文件时会有什么问题?
解答:对实时话音数据的传输是不能使用 TCP 的。这是因为用 TCP 传输话音数据时， 只要一出现差错或丢失， TCP就要重传。 这就产生了额外的时延，有时这种时延会达到很高的数值，使接收方无法容忍。在实时话音通信中，我们宁可丢掉几个分组(这在重放时，还原的话音质量会差一些，但仍然可以听懂)，也不愿意收到太迟来到的分组，因为这样会使重 放的话音质量严重恶化。虽然 UDP 不保证可靠交付，但 UDP 比 TCP 的开销要小很多。因此 只要应用程序接受这样的服务质量就可以使用 UDP。
如果话音数据不是实时播放(边接收边播放)就可以使用 TCP, 因为 TCP 传输可靠。接收端用 TCP 将话音数据接收完毕后，可以在以后的任何时间进行播放。但本题目假定是实时话音数据传输，因此必须使用 UDP。
使用 UDP 传送数据文件时，如果出现了差错， UDP 仅仅是少收了这个出错的报文段 ， 并不通知发送方重传。这样就不能保证正确地传送数据。因此在传送数据文件时，我们都是采用 TCP 来传送的。

 ### <5-16 > 在停止等待协议中，如果不使用编号是否可行?为什么?
解答 :在停止等待协议中，如果不使用编号是不可行的。试考虑下面的例子(见图 T-5-16)。 A 发送报文段 M1, B 收到后发送确认(不编号)。但这个确认很晚才传送到 A。 A 在没有等到确认时，超时重传了 M1
B发送的第一个确认最后到了A, 千是A发送下一个报文段M2, 但M2丢失了。
B 收到 A 发送的重传的 M1, 。但 B 并不知道是重传的，因为报文段没有编号 。 B 无法判断是重传的老报文段，还是新的报文段。 B 只能把 A 发送的重传的 M, 收下，并发送确认。但 这个确认使 A 认为是对其发送的 M2 的确认，于是以为发送的两个报文段 B 都收到了。
这样简单的例子使我们看出，不使用编号， A 以为发送的两个报文段都正确地传送到 B, 而实际上 B 收到了两个重复的报文段。可见在停止等待协议中，如果不使用编号是不可行的。

### <5-17>在停止等待协议中，如果收到重复的报文段时不予理睬(即悄悄地丢弃它 ， 而其他什么也不做)是否可行?试举出具体例子说明理由。
解答: 不可行。
A 发送报文段 M1, B 收到后发送确认 ， 但这个确认丢失了。
A 超时重传报文段 M1, B 收到后不予理睬 。 这就导致 A 再次超时重传报文段 M1 B 收到重复的报文段都不予理睬， A就一直超时重传报文段 M1 。
可见，如果收到重复的报文段时不予理睬是不行的 。

 ### 【5-18】假定在运输层使用停止等待协议。发送方在发送报文段 M。后在设定的时间内 未收到确认，千是重传 M。，但 M。又迟迟不能到达接收方 。 不久，发送方收到 了迟到的对 M。的确认，于是发送下 一 个报文段 M,, 不久就收到了对 M, 的确 认。接着发送方发送新的报文段 M。，但这个新的 M。在传送过程中丢失了。正 巧， 一 开始就滞留在网络中的 M。现在到达接收方。接收方无法分辨出 M。是旧 的。千是收下 M。，并发送确认。显然，接收方后来收到的 M。是重复的，协议 失败了 。试画出双方交换报文段的过程。
 旧的 M。被当成是新的 M。!可见运输层不能使用停止等待协议(编号只有 0 和 1 两种)。

 ### 【5-19】试证明: 当用 n 比特进行分组的编号时，若接收窗口等于 1 (即只能按序接收分组)，则仅在发送窗口不超过 2n- I 时，连续 ARQ 协议才能正确运行 。窗口单位是分组。

### 【5-21 】假定使用连续ARQ协议，发送窗口大小是3,而序号范围是[O,15),而传输媒体保证在接收方能够按序收到分组。在某一时刻，在接收方，下一个期望收到的序号是5。试问:
(1)在发送方的发送窗口中可能出现的序号组合有哪些?
(2)接收方已经发送出的、但仍滞留在网络中(即还未到达发送方)的确认分
组，可能有哪些?说明这些确认分组是用来确认哪些序号的分组。解答:分别回答如下:
(I)在接收方，下一个期望收到的序号是5。这表明序号到4为止的分组都已收到。若这些确认都已到达发送方，则发送窗口最靠前，其范围是[5,7)。
假定所有的确认都丢失了，发送方都没有收到这些确认。这时，发送窗口最靠后，应为 [2 ,4]。因此，发送窗口可以是 [2, 4), (3, 5), [4, 6), [5, 7)中的任何一个。
(2) 接收方期望收到序号 5 的分组，说明序号为 2, 3, 4 的分组都已收到，并且发送了确认 。 对序号为 1 的分组的确认肯定被发送方收到了，否则发送方不可能发送 4 号分组。可见， 对序号为 2, 3,4 的分组的确认有可能仍滞留在网络中。这些确认是用来确认序号为 2,3,4 的 分组的 。

### 【5-22】 主机A向主机B发送一个很长的文件，其长度为L字节。假定TCP使用的MSS 为 1460字节。
(I) 在 TCP 的序号不重复使用的条件下， L 的最大值是多少?
(2) 假定使用上面计算出的文件长度，而运输层、网络层和数据链路层所用的 首部开销共 66 字节，链路的数据率为 10 Mbit/s, 试求这个文件所需的最
短传输时间。
解答: 分别求解如下 :
(1) 可能的序号共2$^{32}$=4294967296个。TCP的序号是数据字段的每一个字节的编号，而 不是每一个报文段的编号。因此，这一小题与报文段的长度无关，即用不到题目给出的 MSS
值。这个文件 L 的最大值就是可能的序号数，即 4294967296 字节。若 1 G B = 2$^{30}$ B , 最大值是 4GB。
(2) 2$^{32}$/1460 = 2941758.422, 需要发送 2941759 个帧。 帧首部的开销是 66 X 2941759= 194156094 字节。 发送的总字节数是= 2$^{32}$ + 194156094 = 4489123390 字节。 数据率 10 Mbit/s = 1.25 MB/s=1250000 字节/秒。
发送 4489123390 字节需时间为: 4489123390 / 1250000 = 3591.3 秒。 即 59.85 分，约 1 小时 。

### 【5-23】 主机A向主机B连续发送了两个TCP报文段，其序号分别是70和100。
试问:(1)第一个报文段携带了多少字节的数据?
(2)主机B收到第一个报文段后，发回的确认中的确认号应当是多少?
(3)如果B收到第二个报文段后，发回的确认中的确认号是180,试问A发送的第二个报文段中的数据有多少字节?
(4)如果A发送的第一个报文段丢失了，但第二个报文段到达了B。B在第二个报文段到达后向A发送确认。试问这个确认号应为多少?
解答:分别求解如下:
(l)第一个报文段的数据序号是 70 到 99, 共 30 字节的数据。
(2) B 期望收到下一个报文段的第一个数据字节的序号是 100, 因此确认号应为 100。 (3) A 发送的第二个报文段中的数据中的字节数是 180- 100 = 80 字节。
(4) B 在第 二个报文段到达后向 A 发送确认，其**确认号应为70。**

### 【5-24】 一个 TCP 连接下面使用 256 kbit/s 的链路，其端到端时延为 128 ms。经测试， 发现吞吐量只有 120 kbit/s。试问发送窗口 W 是多少? (提示:可以有两种答 案，取决于接收端发出确认的时机。)
解答:设 发送窗口= W(bit), 再设发送端连续发送完窗口内的数据所需的时间 =T。有 两种情况:
(a) 接收端在收完一批数据的最后才发出确认，因此发送端经过 (256 ms + T)后才能发送下一个窗口的数据。
(b) 接收端每收到-个很小的报文段后就发回确认，因此发送端经过比 256 ms 略多一些的时间即可再发送数据 。囚此每经过 256 ms 就能发送一个窗口的数据 。
对于(a):
发送窗口 WI120=WI256+256
256W= 120W+ 256 x 256 x 120
发送窗口 W = 256 x 256 x 120 / 136 =57825.88 bit, 约为7228 字节。
对于 (b):
W= 256 xl20 = 30720 bit= 3840 B

### 【5-25】为什么在 TCP 首部中要把 TCP 的端口号放入最开始的 4 个字节?
解答:在 ICMP 的差错报文中(见教材的图 4-28) 要包含 IP 首部后面的 8 个字节的内容， 而这里面有 TCP 首部中的源端口和目的端口 。当 TCP 收到 ICMP 差错报文时，需要用这两个端口来确定是哪条连接出了差错 。

### 【5-26】为什么在 TCP首部中有一个首部长度字段，而 UDP的首部中就没有这个字段? 
解答: TCP首部除固定长度部分外，还有选项，因此 TCP 首部长度是可变的。 UDP首部长度是固定的，不需要这个字段。

### 【5-27】 一个 TCP 报文段的数据部分最多为多少个字节?为什么?如果用户要传送的数据的字节长度，超过 TCP 报文段中的序号字段可能编出的最大序号，问还能否用 TCP 来传送?
 解答: 一个TCP报文段的数据部分最多为65495字节。 数据部分加上TCP首部的20字 节，再加上 IP 首部的 20 字节，正好是 IP 数据报的最大长度 65535 字 节 。当 然，若 IP 首部 包含了选项，则 IP 首部长度超过 20 字节，这时 TCP 报文段的数据部分的长度将小千 65495 字节。
如果用户要传送的数据的字节长度超过 TCP 报文段中的序号字段可能编出的最大序号，仍可用 TCP 来传送。编号用完后再重复使用。但应设法保证不出现编号的混乱 。

### <5-28 > 主机 A 向主机 B 发送 TCP 报文段，首部中的源端口是 m 而目的端口是 n。 当 B 向 A 发送回信时，其 TCP 报文段的首部中的源端口和目的端口分别是什么?
解答:当 B 向 A 发送回信时，其 TCP 报文段首部中的源端口就是 A 发送的 TCP 报文段首部中的目的端口 n, 而 B 发送的 TCP 报文段首部中的目的端口就是 A 发送的 TCP 报文段 首部中的源端口 m。

### <5-29 > 在使用 TCP 传送数据时，如果有一个确认报文段丢失了，也不一定会引起与 该确认报文段对应的数据的重传。试说明理由。
解答:还未重传就收到了对更高序号的确认。

### <5-30 > 设 TCP 使用的最大窗口为 65535 字节，而传输信道不产生差错，带宽也不受限制。若报文段的平均往返时间为 20 ms, 问所能得到的最大吞吐量是多少?
解答:在发送时延可忽略的情况下，每 20ms 可发送 65535 x 8 = 524280 bit 最大数据率= (524280 bit)/ (20 ms) = 26.2 Mbit/s。

### <5-31 > 通信信道带宽为 1 Gbit/s, 端到端传播时延为 10 ms。 TCP 的发送窗口为 65535 字节。试间:可能达到的最大吞吐量是多少?信道的利用率是多少?
解答:发送一个窗口的比特数为 65535x8=524280bit。
所需时间为 (524280 bit)/ (1000000000 bit/s) = 0.524 x 0.001 s = 0.524 ms。
往返时间为 20ms。
最大吞吐量为(0.524280 Mbit) / (20 ms + 0.524 ms) = (0.524280 Mbit) / (20.524 ms) = 25.5Mbit/s。
信道利用率为 (25.5 Mbit/s) / (1000 Mbit/s) = 2.55%。


### 【5-32】什么是 Kam 算法?在 TCP 的重传机制中，若不采用 Kam 算法，而是在收到确认时都认为是对重传报文段的确认，那么由此得出的往返时间样本和重传时间都会偏小。试问:重传时间最后会减小到什么程度?
解答: Kam 算法允许 TCP 能够区分开有效的和无效的往返时间样本，从而改进了往返时间的估算。
若不采用 Kam 算法，而是在收到确认时都认为是对重传报文段的确认，那么由此得出的往返时间样本和重传时间都会偏小。如图 T-5-32 所示， TCP 发送了报文段后，没有收到确认， 千是超时重传报文段。但刚刚重传了报文段后，马上就收到了确认 。 显然，这个确认是对原来发送的报文段的确认 。 但是，根据题意，我们就认为这个确认是对重传的报文段的确认 。
就会很小。这样的往返时间最后甚至可以减小到很接近于零。因此，上述的这种做法是不可取的。

### <5-33 > 假定 TCP 在开始建立连接时，发送方设定超时重传时间 RTO == 6 秒。
(1) 当发送方收到对方的连接确认报文段时，测量出 RTT 样本值为 1.5 秒。试计算现在的 RTO 值。
(2) 当发送方发送数据报文段并收到确认时，测量出 RTT 样本值为 2.5 秒。试计算现在的 RTO 值。
解答: RTO 值计算如下:
(1) 当第一次测量到 RTT 样本时， RT飞值就取为这个测量到的 RTT 样本值 。
因此， RTTs = 1.5 s。
根据 RFC 2988 的建议，当第一次测量时， RT兀值取为测量到的 RTT 样本值的一半。 
因此， RTTO=(l/2)x1.5s==0.75s。
根据教材上(5-5)式， RTO==RTTs+4xRTT0
= 1.5 S + 4 X 0.75 S = 4.5 S
(2) 新的RTT样本=2.5s
按 (5-4)式，新的 RTTs =(1-a)x( 旧的 RTTs)+ax(新的 RTT 样本) = (1 - 1/8) X 1.5 S + 1/8 X 2.5 S = 1.625 S
按(5-6)式，新的RTTD =(1-B)X(旧的RTT0)+Bx| RTTs-新的RTT样本|
= (1-1/4) x 0.75 s + 1/4 x I1.625 s-2.5 s I= 0.78125 = 0.78 s
按(5-5)式， RTO = RTTs + 4 x RTTo
= 1.625 S + 4 X 0.78 S = 4.75 S

### <5-34 >已知第一次测得 TCP 的往返时间 RTT 是 30ms。接着收到了三个确认报文段， 用它们测量出的往返时间样本 RTT 分别是: 26 ms, 32 ms 和 24 ms。设a=O.l 。 试计算每一次的新的加权平均往返时间值 RTTs。讨论所得出的结果。
解答:按教材上(5-4)式:新的 RTTs=(l-a)x(旧的 RTTs)+ax(新的 RTT样本)
第一次算出: RTTs=(1-0.1)x30+0.1x26=29.6ms
第二次算出: RTTs = (1- 0.1) x 29.6 + 0.1 x 32 = 29.84ms
第三次算出: RTTs = (I - 0.1) x 29.84 +0.1 x 24 = 29.256 ms
三次算出加权平均往返时间分别为 29.6, 29.84 和 29.256 ms。
可以看出， RTT的样本值变化多达20%时((30-24)/30=6/30= 1/5=20%), 加权平均往返时间RT飞的变化却很小。

### 【5-35】试计算 一个包 括五段链路的运输连接的单程端到端时延。 五段链路中有两段是 卫星链路，有 三段是广 域网链路 。 每条卫星链路又由上行链路和 下行链路两部 分组成。可以取这两部分的传播时延之和为 250 ms。每一个广 域网的范围为 1500 km, 其传播时延可按 150000 km/s 来计算。各数据链路速率为 48 kbit/s, 帧长为 960 位。
解答:广域网的传播时延= (1500 km) / (150000 km/s) = 0.01 s = 10 ms 
每一个结点的传输时延= (960 bit)/ (48000 bit/s) = 0.02 s = 20 ms
可见总共需时3*(10+20) + 2*(250+20) = 630 ms。

<5-36 > 重复 5-35 题，但假定其中的一个陆地上的广域网的传输时延为 150 ms。 解答:计算同 5-35 题 。
总共需时 1*(10+150)+2*(10+20) + 2*(250+20) = 760 ms。

### 【5-37】在 TCP 的拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法?这里 每 一 种算法各起什么作用?“乘法减小”和“加法增大“各用在什么情况下?
解答:慢开始算法的思路是这样的:当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。经验证明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd,可以使分组注入到网络的速率更加合理。使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就加倍。
为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。当cwnd>ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1,而不是加倍。这样，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。
快重传算法首先要求接收方匋收到一个失序的报文段后，就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)，而不要等待自已发送数据时才进行捎带确认。
快恢复算法，其过程有以下两个要点:
(1)当发送方连续收到三个重复确认时，就执行"乘法减小"算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。
(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法(“加法增大")'使拥塞窗口缓慢地线性增大。
"乘法减小”是指不论在慢开始阶段还是拥塞避免阶段，只要出现超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh减半，即设置为当前的拥塞窗口的一半(与此同时，执行慢开始算法)。当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入到网络中的分组数。
“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。

### 【5-38】设 TCP 的 ssthresh 的初始值为 8 (单位为报文段)。当拥塞窗口上升到 12 时网 络发生了超时， TCP 使用慢开始和拥塞避免。试分别求出第 1 轮次到第 15 轮 次传输的各拥塞窗口大小。你能说明拥塞窗口每一次变化的原因吗?

1 网络发生了超时， TCP使用慢开始算法
2 拥塞窗口值加倍
4 拥塞窗口值加倍
8 拥塞窗口值加倍，这是 ssthresh 的初始值
9 TCP 使用拥塞避免算法，拥塞窗口值加 1
10 TCP 使用拥塞避免算法，拥塞窗口值加 1
11 TCP 使用拥塞避免算法，拥塞窗口值加 1
12 TCP 使用拥塞避免算法，拥塞窗口值加 1
1 网络发生了超时， TCP 使用慢开始算法
2 拥塞窗口值加倍
4 拥塞窗口值加倍
6 拥塞窗口值加倍，但到达 12 的一半时，改为拥塞避免算法 
7 TCP 使用拥塞避免算法，拥塞窗口值加 l
8 TCP 使用拥塞避免算法，拥塞窗口值加 1
9 TCP 使用拥塞避免算法，拥塞窗口值加 1

### 【5-40】 TCP 在进行流量控制时，是以分组的丢失作为产生拥塞的标志 。 有没有不是因 拥塞而引起分组丢失的情况?如有，请举出 三种情况 。
解答:不是因拥塞而引起分组丢失的情况是有的，举例如下 。
第一种情况:当 IP 数据报在传输过程中需要分片，但其中的一个数据报片未能及时到达终点，而终点组装 IP 数据报已超时，因而只能丢弃该数据报 。
第二种情况: IP 数据报已经到达终点，但终点的缓存没有足够的空间存放此数据报。
第三种情况:数据报在转发过程中经过一个局域网的网桥，但网桥在转发该数据报的帧时没有足够的存储空间而只好丢弃。

### 【5-41 】用 TCP 传送 512 字 节的数据。设窗口为 100 字节，而 TCP 报文段每次也是传 送 100 字节的数据 。 再设发送方和接收方的起始序号分别选为 100 和 200, 试 画出类似于教材图 5-28 的工作示意图。从连接建立阶段到连接释放都要画上。
解答:要传送的 512 B 的数据必须划分为 6 个报文段传送，前 5 个报文段各 100 B, 最后 一 个报文段传送 12 B。图 T-5-41 是双方交互的示意图。下面进行简单的解释 。
报文段 #1: A 发起主动打开，发送 SYN 报文段，处于 SYN-SENT 状态，并选择初始序 号 seq== 100。 B 处于 LISTEN 状态。
报文段#2: B确认A的SYN报文段， 因此ack==101(是A的初始序号加1)。 B选择初 始序号seq==200。 B进入到SYN-RCVD状态。
报文段#3: A发送ACK报文段来确认报文段#2, ack==201(是B的初始序号加I)。 A 没有在这个报文段中放入数据 。 因为 SYN 报文段 #1 消耗了一个序号，因此报文段 #3 的序号 是 seq== 101 。这样， A 和 B 都进入了 ESTABLISHED 状态。
报文段#4:A发送100字节的数据。报文段#3是确认报文段，没有数据发送，报文段#3并不消耗序号，因此报文段#4的序号仍然是seq==10I。A在发送数据的同时，还确认B的报文段#2,因此ack==201。
报文段#5:B确认A的报文段叫。由千收到了从序号101到200共100字节的数据，因此在报文段#5中，ack==201(所期望收到的下一个数据字节的序号)。B发送的SYN报文段#2消耗了一个序号，因此报文段#5的序号是seq==201,比报文段#2的序号多了一个序号。在这个报文段中，B给出了接收窗口rwnd=100。
从报文段#6到报文段#13都不需要更多的解释。到此为止，A已经传送了500字节的数据。值得注意的是，B发送的所有确认报文段都不消耗序号，其序号都是seq=201。
报文段#14:A发送最后12字节的数据，报文段#14的序号是seq=601。
报文段#15: B发送对报文段#14的确认。 B收到从序号601到612共12字节的数据。 因此报文段#15 的确认号是 ack=613 (所期望收到的下一个数据字节的序号 )。
需要注意的是，从报文段 #5 一 直到报文段 #15, B 一共 发送 了 6 个确认，都不消耗序号， 因此 B 发送的报文段#15 的序号仍然和报文段#5 的序号一样， 即 seq=201。
报文段#16: A 发送 FIN 报文段 。 前面所发送的数据报 文段#14 已经用掉了序号 601 到 602, 因此报文段 #16 的序号是 seq= 613。 A 进入 FIN-WAIT-I 状态 。 报文段 #16 的确认号 ack =202。
报文段 #17: B 发送确认报文段，确认号 ack = 614 , 进入 CLOSE-WAIT状态 。 由于确认报文段不消耗序号，因此报文段 #17 的序号仍然和报文段 #15 的一样，即 seq= 201 。
报文段#18: B 没有数据要发送，就发送 FIN 报文段 #18, 其序号仍然是 seq=201 。这个FIN 报文段会消耗 一个序号 。
报文段#19: A 发送最后的确认报文段。报文段#16 的序号是 613, 已经消耗掉了。因此现在的序号是 seq = 614。但这个确认报文段并不消耗序号。

### 【5-42】在教材的图 5-29 中所示的连接释放过程中，在 ESTABLISHED 状态下， B 能否 先不发送 ack = u + I 的确认?(因为 B 在后面要发送的连接释放报文段中，仍 有ack=u+I 这一信息。)
解答:如果 B 不再发送数据了，可以把两个报文段合并成为 一个 ，即只发送 FIN +ACK 报文段。但如果 B 还有数据要发送，那就不行，因为 A 迟迟收不到确认，就**会以为刚才发送的FIN 报文段丢失了**，就超时重传这个 FIN 报文段，浪费网络资源。

### 【5-43】在教材的图 5-30 中，在什么情况下会发生从状态 SYN-SENT 到状态 SYN-RCVD的变迁?
解答:当 A 和 B 都作为客户，即同时主动打开 TCP 连接 。这时的每一方的状态变迁都是:
CLOSED -> SYN-SENT -> SYN-RCVD -> ESTABLISHED

### 【5-44】试以具体例子说明为什么一个运输连接可以有多种方式释放。可 以设两个互相通信的用户分别连接在网络的两结点上。
解答:设A是客户， B是服务器。 A和B建立了TCP连接后， A向B传送一个文件， 当 A 收到来自 B 的确认后，文件的传送任务就完成了。 A 就释放 TCP 连接， B 也随之释放 TCP 连接 。这就是最简单的一种连接释放方法。
但也可以有另一种情况。 A 发送一个文件，里面含有一些数据，需要 B 进行修改。 B 收到文件后就发送了确认 。 A 收到确认报文段后，就可以释放 TCP 连接，因为 A 已经没有数据要向 B 发送了，可以向 B 发送 FIN 报文段，然后 B 给出确认。这时的 TCP 连接就处于半关闭状态。 A 不能再发送数据了，但 B 可以发送数据。等 B 向 A 发送完修改后的数据， B 再 向 A 发送 FIN 报文段， A 确认后， TCP 连接就释放了。这就是另一种连接释放的方法。

### 【5-45】解释为什么突然释放运输连接就可能会丢失用户数据，而使用 TCP 的连接释放方法就可保证不丢失数据 。
解答:我们假定 A 和 B 之间建立了 TCP 连接，并且已经交换了一些数据。
现在 A 应当发送的数据都已经发送完毕了。如果 A 现在突然把 TCP 连接释放掉，那么有可能出现这种情况: A 发送给 B 的某些报文段正在网络中传送，但因某种原因，报文段丢失了。 A 以为 B 应当收到 A 所发送的全部报文段，但事实上，有些报文段 B 没有收到。这就是题目所说的”可能会丢失用户数据“ 。
我们再假定: A 已经收到了来自 B 的确认， B 向 A 确认已经收到了 A 所发送的全部数据。 如果 A 现在突然把 TCP 连接释放掉，那么 A 发送给 B 的数据是不可能丢失了，因为 B 已经确认收到了 A 所发送的全部数据 。 现在可能会丢失的，是 B 无法向 A 发送一些数据了(如果 B 还有这样的数据)，因为 TCP 连接已经突然释放了 。
因此，必须使用 TCP 的连接释放，这样就可保证不丢失数据。

### 【5-46】 试用具体例子说明为什么在运输连接建立时要使用三报文握手 。 做可能会出现什么情况。
在上一个 TCP 连接中， A 向 B 发送的连接请求 SYN 报文段滞留在网络中的某处。千是 A 超时重传 ，与 B 建立了 TCP 连接，交换了数据，最后也释放了 TCP 连接。
但滞留在网络中某处的陈旧的 SYN 报文段，现在突然传送到 B 了。如果不使用三报文握手，那么 B 就以为 A 现在请求建立 TCP 连接，于是就分配资源，等待 A 传送数据。但 A 并 没有想要建立 TCP 连接，也不会向 B 传送数据。 B 就白白等待着 A 发送数据。
如果使用三报文握手，那么 B 在收到 A 发送的陈旧的 SYN 报文段后，就向 A 发送 SYN 报文段，选择自己的序号seq=y, 并确认收到A的SYN报文段，其确认号ack=x+l。当A 收到 B 的 SYN 报文段时，从确认号就可得知不应当理睬这个 SYN 报文段(因为 A 现在并没有发送seq=x的SYN报文段)。这时， A发送复位报文段。在这个报文段中， RST=1, ACK = 1, 其确认号 ack = y +1 我们注意到，虽然 A 拒绝了 TCP 连接的建立(发送了复位报文段) ， 但对 B 发送 的 SYN 报文段还是确认收到了 。
B 收到 A 的 RST 报文段后，就知道不能建立 TCP 连接，不会等待 A 发送数据了。

### 【5-47】 一客户向服务器请求建立 TCP 连接。客户在 TCP 连接建立的三报文握手中的 最后一个报文段中捎带上 一些 数据，请求服务器发送一个长度为 L 字节的文件。 假定:
(l) 客户和服务器之间的数据传送速率是 R 字节/秒，客户与服务器之间的往返时间是 RTT (固定值)。
(2) 服务器发送的 TCP 报文段的长度都是 M 字节，而发送窗口大小是 nM字节。 
(3) 所有传送的报文段都不会出现差错(无重传)，客户收到服务器发来的报文段后就及时发送确认 。
(4) 所有的协议首部开销都可忽略，所有确认报文段和连接建立阶段的报文段的长度都可忽略(即忽略这些报文段的传输时间) 。
 试证明，从客户开始发起连接建立到接收服务器发送的整个文件所需的时间 T是: T= 2 RTT+ L/R 当 nM> R (RTT) + M
或 T=2RTT+L/R+(K — 1)[M/R+ RTT — nM/R] 当 nM < R (RTT) + M 其中 K= L/nM, 符号「xl表示若x不是整数，则把x的整数部分加 1。
(提示:求证的第一个等式发生在发送窗口较大的情况，可以连续把文件发送完。求证的第二个等式发生在发送窗口较小的情况，发送几个报文段后就必须停顿下来，等收到确认后再继续发送。建议先画出双方交互的时间图， 然后再进行推导 。)
解答:
(a) 先看图 T-5-47(a)。
M/R 是一个报文段的发送时间(一个报文段的长度除以数据率) 。
nM 是窗口大小， nM/R 是把窗口内的数据都发送完所需的时间。
如果 n/R >M/R+ RTT, 那么服务器在发送窗口内的数据还没有发送完，就收到客户的确认，因此，服务器可以连续发送，直到全部数据发送完毕。
这个不等式两边都乘以 R, 就得出等效的条件:
当 nM> R (RTT) + M 时，发送窗口内的数据还没有发送完就收到确认，因此，服务器可以连续发送，直到全部数据发送完毕。 因此，客户接收全部数据所需的时间是:T= 2 RTT+ L/R 当 nM> R (RTT) + M
(b) 当 nM < R (RTT) + M 时，服务器把发送窗口内的数据发送完毕时还收不到确认，因此必须停止发送 。从图 T-5-47(b)可看出，停止的时间间隔是 M/R+ RTT- nM/R。
整个文件 L 要划分为 K= 『L/nM 次传送停止的时间间隔有 (K— 1)个。这样就证明了求 证的公式 :
T=2RTT+L/R+(K- 1)[M/R+RTT-nM/R] 当nM< R(RTT)+M

 ### <5-48 > 网络允许的最大报又段长度为 128 字节，序号用 8 位表示，报文段在网络中的 寿命为 30 秒。求发送报文段的一方所能达到的最高数据率。
解答 :根据题意，本题应当有以下的一些假定。
(1) 本题不是使用 TCP 协议，因为序号字段是 8 位，而不是 TCP 的 32 位 。
(2) 既然不是使用 TCP 协议，当然也不是使用 TCP 协议的首部。现在的报文段的首部是什么样子，和我们解题没有关系。我们不必管它。我们只需要知道的是，现在的报文段的首部中有一个序号字段。
(3) 显然，现在不是给报文中的每一个字节编上序号，而是给每一个报文编 一个序号。
(4) 报文段的传送应当使用滑动窗口协议(而不是停止等待协议)，这样可得到较高的效率。
我们知道，在使用滑动窗口协议时，在没有收到确认的情况下， 8 位的序号字段可连续发送255个序号 C2$^n$- 1) 的报文段。 这样，一共可发送的比特数是: 255 x 128 x 8 = 261120 bit。 算出发送报文段的一方所能达到的最高数据率是:
(261120 bit) / (30 s) = 8704 bit/s = 8.704 kbit/s。

### <5-49> 下面是以十六进制格式存储的一个 UDP 首部: CB84000D001COO1C
试问:
(1) 源端口号是什么?
(2) 目的端口号是什么?
(3) 这个用户数据报的总长度是多少?
(4) 数据长度是多少?
(5) 这个分组是从客户到服务器方向的，还是从服务器到客户方向的? (6) 客户进程是什么?
解答:分别回答如下:
(I) 源端口号是最前面的四位十六进制数字 (CB84$_{16}$), 算出十进制的源端口号是
12 X 16$^3$+ 11 X 16$^2$+8 X 16 +4x 1=49152+2816+ 128+4=52100。
(2) 目的端口号是第二个四位十六进制数字 (000D$_{16}$，算出十进制的目的端口号是 13。 
(3) 第三个四位十六进制数字 (OO1C$_{16}$) 定义了整个 UDP 分组的长度，算出是1 X 16 +12X 1=28字节。
(4) 数据的长度是整个分组的长度减去首部的长度 ，也就是 28 - 8 = 20 字节。
(5) 因为目的端口号是 13 (熟知端口)，所以这个分组是从客户到服务器的。
(6) 从 RFC 867 可以得知，这个客户进程是 Daytime。当 Daytime 服务器收到客户发送的UDP 用户数据报后，就把现在的日期和时间以 ASCII 码字符串的形式返回给客户 。

### <5-50 > 把教材上的图 5-7 计算 UDP 检验和的例子自已具体演算一下，看是否能够得出书上的计算结果。
 解答:
可以使用两种方法进行二进制反码求和的运算 。一种方法是把这14行的16位数据一起从低位到高位逐位相加。另一种方法是把这14行的16位数据两行两行地相加(即二进制反码求和)。
我们这里使用后一种方法 ，这要相加13 次 。
第 1 行和第 2 行相加，得 10I0000I O11110l I 。
再和第 3 行相加，得 1 O100I100 01111110。请注意，最左边(最高位) 的 1 是进位得到
的 1, 这要和最低位相加。因此和第 3 行相加后，得 01001100 01111111。最低位的 1 就是由 最高位的进位得到的。这叫做“回卷”。
再和第 4 行相加，得 01O1101O10001OI0。 再和第 5 行相加， 得 01O110IO10011O11。 再和第 6 行相加，得 01011010 10101010。 再和第 7行相加，得 01O111101110100I。 再和第 8 行相加 ，得 0101111011110110。 再和第 9 行相加，得 0IO11111 0000010I。 第10行是全O, 不用再计算相加。
再和第 11 行相加，得 10110011 01001010。
再和第 12 行相加，得 00000110 10011111 。这里最低位的 1 是由最高位的进位回卷得 到的 。
再和第 13 行相加，得 01001111 11101 101 。
再和第 14 行相加，得 10010110 11101101。这就是二进制反码求和的结果。把这个结果 求反码 (1 换成 0而 0换成 1)' 得出: 0IIO1001000I00I0。这就是应当写在检验和字段的数。 和书上给出的结果是 一 样的 。
UDP 用户数 据报传送到接收端后，再进行检验和计算。这就是 把收到的 UDP 用户数据 报连同伪首部 ( 以及可能的填充全零字节)一起，按二进制反码求这些 16 位字的和。当无差 错时其结果应为 全 1 。否 则就表明有差错出现，接收方就应丢弃这个 UDP 用户数据报(也可以上交给应用层，但附上出现了差错的警告 )。)

### <5-51 > 在以下几种情况下， UDP 的检验和在发送时的数值分别是多少? (1) 发送方决定不使用检验和 。(2) 发送方使用检验和，检验和的数值是全 1 。(3) 发送方使用检验和，检验和的数值是全 0。
解答:
(1)UDP 规定， UDP 的上层用户可以关闭检验和的计算(即在 UDP 的传送过程中，不使 用检验和这个检错功能)。这样做的好处是可以提高 UDP 的传送速度(但要牺牲一些可靠性)。 如果发送方决定不使用检验和，那么发送方的检验和的值应当置为全 0。这表示这个数值不是计算出来的，而是发送方关闭了检验和这个功能。
(2) 如果发送方使用检验和，但检验和的数值是全1 。
(2) 如果发送方使用检验和，但检验和的数值是全1。
我们可以想一想，怎么会出现这种情况。如果计算检验和最后的结果是全 1, 就表明得 出这个结果的前 一个步骤(即进行二进制反码求和)的结果是全 0。在什么情况下，伪首部和整个UDP按16位字进行二进制反码求和的结果是全O?这就是伪首部和整个UDP的所有字段都是0。但很明显，这是不可能的。所有的地址和数据都是O,还有什么意义?不要以为两个1相加就是0。不对。两个1相加按二进制反码求和的结果是10。这里的1是进位。因此按照计算检验和的规矩来计算，对真实的UDP用户数据报不可能得出检验和的数值是全1。
但是，计算检验和时的倒数第二步，即按二进制反码求和的结果却有可能是全1。在这种情况下，最后一步求反码，就会得出检验和是全0。但是前面我们已经讲过，检验和置为全0是表示发送方不使用检验和。这样就产生了疑问:如果检验和是全O,是发送方不使用检验和?还是使用了检验和但检验和碰巧是全O?无法确定。于是UDP协议就规定:如果计算检验和的结果刚好是全O,那么就把它人为地置为全1。因为前面已经讲过，全1的检验和是不可能由计算产生出来的。因此接收方一旦收到检验和是全1的UDP用户数据报，就知道这是人为的，真正的检验和其实是全0。
(3) 发送方使用检验和，检验和的数值是全 0。
前面已经讲过，这是不可能的。如果发送方计算出来的检验和是全 O, 那也要把它变成全1后再发送出去。

### <5-52> UDP 和 IP 的不可靠程度是否相同?请加以解释 。
解答: UDP 和 IP 都是无连接的协议和不可靠传输的协议。 UDP 用户数据报和 IP 数据报的首部都有检验和字段。当检验出有差错时，就把收到的 UDP 用户数据报或 IP 数据报丢弃。 这是它们的相同之处。
但 UDP 和 IP 的可靠性是有些区别的。 UDP 用户数据报的检验和是既检验 UDP 用户数据报的首部又检验整个的 UDP 用户数据报的数据部分，而 IP 数据报的检验和仅仅检验 IP 数据报的首部。 UDP 用户数据报的检验和还增加了伪首部，即还检验了下面的 IP 数据报的源 IP 地址和目的IP地址。

### <5-53 > UDP 用户数据报的最小长度是多少?用最小长度的 UDP HJ 户数据报构成的最 短 IP 数据报的长度是多少?
解答: UDP 用户数据报的最小长度是 8 字节，即仅有首部而没有数据。用最小长度的 UDP 源用户数据报构成的最短 IP 数据报的长度是 28 字节。此 IP 数据报具有 20 字节的固定首部，首部中没有可选字段。

### <5-54 > 某客户使用 UDP 将数据发送给一服务器，数据共 16 字节。试计算在运输层的 传输效率(有用字节与总字节之比)。
解答: UDP 用户数据报的总长度= 8 + 16 = 24 字节。 因此，在运输层的传输效率= 16 / 24 = 0.667。

### <5-55 > 重做习题 5-54, 但在 IP 层计算传输效率。假定 IP 首部无选项。 
解答: IP数据报的总长度=20+24=44字节。
因此，在 IP层的传输效率= 16/44=0.364。

### <5-56 > 重做习题 5-54, 但在数据链路层计算传输效率。假定 IP 首部无选项，在数据链路层使用以太网。
解答:以太网有 14 字节的首部， 4字节的尾部 (FCS 字段)。但其数据字段的最小长度是46字节，而我们的 IP 数据报仅有 44 字节，因此还必须加上 2 字节的填充。这样，以太网的总长度= 14+4+2+44=64字节。
因此，在数据链路层的传输效率= 16/64=0.25。 如果再考虑到发送以太网的帧之前还有 8 字节的前同步码。把这 8 字节计入后，在数据
链路层的传输效率= 16/72=0.222。

### <5-57 > 某客户有 67000 字节的分组。试说明怎样使用 UDP 数据报将这个分组进行传送。 
解答: 一个UDP 用户数据报的最大长度是 65535 字节。现在的长度超过了这个限度，因此不能使用一个 UDP 用户数据报来传送。必须进行分割(例如，分割成为两个 UDP 用户数据报)，使其长度不超过以上的限度。

### 【5-58】 TCP 在 4:30:20 发送了一个报文段。它没有收到确认 。在 4:30:25 它重传了前面这个报文段。它在 4:30:27 收到确认。若以前的 RTT 值是 4 秒，根据 Kam 算法，新的 RTT 值是多少?
解答 :根据 Kam 算法 ，**只要是 TCP 报文段重传了，就不采用其往返时间样本。**本题中收到的确认足在币传后收到的 。 囚此 RTT 值没有变化，仍然是以前的数值 (4 秒)。

### <5-59 > TCP 迕接使用 1000 字节的窗口值，而上一次的确认号是 22001 。它收到了一个报义段 ，确认了宁节 22401。试用图来说明在这之前与之后的窗口情况。
解答: 这里要注意的是，发送窗口11 为 1000 字节，窗口里面的序号也正好是 1000 个。号码小的在后面，即在图的左方。另外一点要注意的是，发送方收钊的确认表示接收方期望能够收到的序号，也就是发送方要发送的序号。这个序号应当在发达窗口的最前加(最右方) 。


### <5-60 > 同上题。但接收方收到确认字节为 22401 的报文段时，其窗口字段变变为 1200字节。试用图来说明在这之前与之后的窗口情况。
解答:，发送窗口变成1200字节后，窗口字段变为：22401-23600

### <5-61 > 在本题中列出的 8 种情况下，画出发送窗口的变化，并标明可用窗口的位置。
已知主机 A 要向主机 B 发送 3 KB 的数据。在 TCP 连接建立后， A 的发送窗口大小是2KB。 A的初始序号是0。
(1) 一开始A发达I KB的数据。
(2) 接着 A 就一直友送数剒，直到把发送窗口用先 。 
(3) 发送方 A 收到对第 1000 号字节的确认报文段。 
(4) 发送方 A 再发送 850B 的妏据。
(5) 发送方A收到ack=900们确认报文段。
(6) 发送方 A 收到对第 2047 号字节的确认报文段。 
(7) 发送方 A 把剩下的数据全部都发送完。
(8) 发送方A收到ack==3072的确认报文段。
解答:(1) 我们应当注意到，发送窗口 =2KB 就是 2 X 1024 = 2048 字节。因此，发送窗口应当 是从 0 到第 2047 字节为止，长度是 2048 字节。 A 开始就发送了 1024 字节，因此发送窗口中 左边的 1024 个字节已经用掉了(窗口的这部分为灰色)，而可用窗口是白色的，从第 1024 字 节到第 2047 字节为止。请注意，不是到第 2048 字节为止，因为第一个字节的编号是 0 而不 是1。
(2) 发送方 A 一直发送数据，直到把发送窗口用完。这时，整个窗口都已用掉了，可用窗口的大小已经是零了，一个字节也不能再发送了。
(3) 发送方 A 收到对第 1000 号字节的确认报文段，表明 A 收到确认号 ack = 1001 的确 认报文段。这时，发送窗口的后沿向前移动，发送窗口从第 1001 字节(不是从第 1000 字节) 到第 3048 字节(不是第 3047 字节)为止。可用窗口从第 2048 字节到第 3048 字节。
(4) 发送方 A 再发送 850 字节，使得可用窗口的后沿向前移动 850 字节，即移动到 2898 字节。现在的可用窗口从第 2898 字节到第 3048 字节。
(5) 发送方 A 收到 ack = 900 的确认报文段，不会对其窗口状态有任何影响。这是个迟到的确认。
(6) 发送方 A 收到对第 2047 号字节的确认报文段。 A 的发送窗口再向前移动。现在的发 送窗口从第 2048 字节开始到第 4095 字节。可用窗口增大了，从第 2898 字节到第 4095 字节。
 (7) 发送方 A 把剩下的数据全部都发送完 。 发送方 A 共有 3 KB (即 3072 字节)的数据， 其编号从 0 到 3071 。因此现在的可用窗口变小了，从第 3072 字节到第 4095 字节。
(8) 发送方 A 收到 ack = 3072 的确认报文段，表明序号在 3071 和这以前的报文段都收到了，后面期望收到的报文段的序号从 3072 开始。因此新的发送窗口的位置又向前移动，从第3072 号到第 5119 号。整个发送窗口也就是可用窗口 。

### <5-62 > TCP 连接处千 ESTABLISHED 状态 。 以下的事件相继发生:
(I) 收到一个FIN报文段。
(2) 应用程序发送“关闭“报文 。
在每一个事件之后，连接的状态是什么?在每一个事件之后发生的动作是什么?
解答
(1) 处于 ESTABLISHED 状态又能够收到一个 FIN 报文段的，只有 TCP 的服务器端而不会是客户端 。当这个服务器收到 FIN 报文段时，服务器就向客户端发送 ACK 报文段，并进入到 CLOSE-WAIT 状态。这是被动关闭。请注意，这时客户端不会再发送数据了，但服务器端如还有数据要发送给客户端，那么还是可以继续发送的 。
(2) 应用程序发送“关闭“报文给服务器，表明没有数据要发送了 。这时服务器就应当发送 FIN 报文段给客户，然后转换到 LAST-ACK 状态，并等待来自客户端的最后的确认 。
以上的状态转换可参考教材上的图 5-30。

### <5-63> TCP 连接处于 SYN-RCVD 状态。以下的事件相继发生: 
(1) 应用程序发送“关闭“报文。
(2) 收到FIN报文段。在每一个事件之后，连接的状态是什么?在每一个事件之后发生的动作是什么?
解答:
(1) 处于 SYN-RCVD 状态而又能够收到应用程序发送的“关闭“报文的，只有 TCP 的客户端而不会是服务器端。这时，客户端就应当向服务器端发送 FIN 报文段，然后进入到 FIN-WAIT-1 状态。
(2) 当客户收到服务器端发送的 FIN 报文段后，就向服务器发送 ACK 报文段，并进入到CLOSING 状态。 以上的状态转换可参考教材上的图 5-30。

### <5-64 >TCP 连接处千 FIN-WAIT-I 状态。以下的事件相继发生:
(1) 收到ACK报文段。
(2) 收到FIN报文段。
(3) 发生了超时。 在每一个事件之后，连接的状态是什么?在每一个事件之后发生的动作是什么?
 解答:
(I) 处千 FIN-WAIT-I 状态的只有 TCP 的客户。当收到 ACK 报文段后， TCP 客户不发送任何报文段，只是从 FIN-WAIT-I 状态进入到 FIN-WAIT-2 状态 
(2) 在收到 FIN 报文段后， TCP 客户发送 ACK 报文段，并进入到 TIME-WAIT 状态。
(3) 当发生了超时，也就是在经过了 2 MSL 时间后， TCP 客户进入到 CLOSED 状态。

### <5-65 > 假定主机 A 向 B 发送一个 TCP 报文段。在这个报文段中，序号是 50, 而数据一共有 6 字节长。试问，在这个报文段中的确认字段是否应当写入 56?
解答:在这个报文段中的确认字段应当写入的是 A 期望下次收到 B 发送的数据中的第一个字节的编号，而这个数值是 A 已经收到的数据中的最后一个字节的编号加 1 。然而这些在题目中并未给出。题目给出的是 A 向 B 发送的数据中第一个字节的编号是 50, 并且在这个报文段中共有 6 字节的数据。这些都和此报文段中的确认字段是什么毫无关系。因此 ，现在我们无法知道在这个报文段中的确认字段应当写入的数值。

### <5-66 > 主机 A 通过 TCP 连接向 B 发送 一个很长的文件，因此这需要分成很多个报文 段来发送。假定某一个TCP报文段的序号是X, 那么下一个报文段的序号是否 就是 x+I 呢?
解答:假定某一个 TCP 报文段的序号是 X, 那么下一个报文段的序号应当是 x+n, 这里 的 n 是这个报文段中的数据长度的字节数。如果 n == 400, 那么下一个报文段的序号应当是 x +400。若在此报文段中仅有一个字节的数据，则下一个报文段的序号才是 x+ 1。

### <5-67 > TCP 的吞吐量应当是每秒发送的数据字节数，还是每秒发送的首部和数据之和的字节数?吞吐量应当是每秒发送的字节数，还是每秒发送的比特数?
解答: TCP 的吞吐量本来并没有标准的定义，可以计入首部，也可以不计入首部，但应当说清楚。不过，从拥塞控制来看，拥塞窗口和发送窗口针对的都是 TCP 报文段中的数据字段，而重要的参数 MSS 也是指 TCP 报文段中的数据字段的长度，因此，把 TCP 的吞吐量定义为每秒发送的数据字节数是比较方便的。
计算机内部的数据传送是以每秒多少字节作为单位的，而在通信线路上的数据率则常用 每秒多少比特作为单位。这两种表示方法并无实质上的差别。在上面的习题中，因为 MSS 是用字节作为单位，因此，用每秒发送多少字节作为 TCP 吞吐量的单位就比较简单一些。

### <5-68> 在 TCP 的连接建立的三报文握手过程中，为什么第三个报文段不需要对方的确认?这会不会出现问题?
解答:关于这个问题，还不能简单地用“是”或“否”来回答 
我们假定 A 是客户端，是发起 TCP 连接建立的一方。现在假定三报文握手过程中的第三个报文段(也就是 A 发送的第二个报文段——确认报文段)丢失了，而 A 并不知道 。这时 ， A 以为对方收到了这个报文段，以为 TCP 连接已经建立了，千是就开始发送数据报文段给 B。 
B 由于没有收到三报文握手中的最后一个报文段 (A 发送的确认报文段)，因此 B 就不能 进入 TCP 的 ESTABLISHED 状态("连接已建立“状态)。 B 的这种状态可以叫做“半开连接", 即仅仅把 TCP 连接打开了 一 半。在这种状态下， B 虽然已经初始化了连接变 酰和缓存，但是 不能够接收数据 。 通常， B 在经过一段时间后(例如， 一 分钟后)，如果还没有收到来自 A 的 确认报文段，就终止这个半开连接状态，那么 A 就必须重新建立 TCP 连接 。 因此在这种情况 下，第三个报文段 CA 发送的第二个报文段)的丢失，就导致了 TCP 连接无法建立 
但是，假定 A 在这段时间内，紧接着就发送了数据。我们知道， TCP 具有累积确认的功 能。在 A 发送的数据报文段中，自己的序号没有改变，仍然是和丢失的确认帧的序 号一样(丢 失的那个确认帧不消耗序号)，并且确认位 ACK= L 确认号也是 B 选择的初始序号加 1。当 B 收到这个报文段后，从 TCP 的首部就可以知道， A 已确认收到了 B 刚才发送的 SYN +ACK 报文段，于是就进入了 ESTABLISHED 状态("连接已建立“状态)。接着，就接收 A 发送的 数据。在这种情况下， A 丢失的第二个报文段对 TCP 的连接建立就没有影响 。
大家知道， A 在发送第二个报文段时，可以有两种选择:
(1) 仅仅是确认而不携带数据，数据接着在后面发送 。
(2) 不仅是确认，而且携带上自己的数据。
在第一种选择时， A 在下一个报文段发送自己的数据。但下一个报文段的首部中仍然包括了对 B 的 SYN+ACK 报文段的确认，即和第二种选择发送的报文段 一 样。
在第二种选择时， A 省略了单独发送一个确认报文段。
从这里也可以看出， A 发送的第二个仅仅是确认的报文段，是个可以省略的报文段，即使丢失了也无妨，只要下面紧接着就发送数据报文段即可。

### <5-69 > 现在假定使用类似 TCP 的协议(即使用滑动窗口可靠传送字节流)，数据传输速率是 l Gbit/s, 而网络的往返时间 RTT = 140 ms。假定报文段的最大生存时间是 60 秒。如果要尽可能快地传送数据，在我们的通信协议的首部中，发送窗口和序号字段至少各应当设为多大?
解答:发送窗口至少应当能够容纳的比特数=往返时间 x 数据率= RTT x l Gbit/s = 140 x 10$^{-3}$ s x 10$^9$ bit/s = 140 x 10$^6$ bit= 17.5 x 10$^6$ 字节
我们知道，每一个字节的数据需要有一个编号。假定发送窗口一共有 w 位，那么总的号 码数应当大千 17.5 X 10$^6$ 字节。即:
2$^w$ >= 17500000
那么， w >= log$_2$ 17500000 = log$_10$ 17500000 / log$_10$ 2 = 24.06
可见使用 24 位的发送窗口差一点，必须使用 w = 25 位的发送窗口才行。 TCP 的窗口字段为 16位。
再看看 60 秒钟以 l Gbit/s 的速率可以发送 60 s x 10$^9$ bit/s = 7.5 x 10$^9$ 字节的数据 。 假定需要 n 位的序号字段，那么总的序号数应当大千 7.5 X 10$^9$ 字节，即:
2$^w$ >= 7.5X 10$^9$
解出 n >= log2(7.5 x 10$^9$) = log10(7.5 x 10$^9$) / log$_{10}$ 2 =[(log$_{10}$ 7.5) + 9] / log$_{10}$ 2 = 32.8 因此，取序号字段长度 n = 33 位即可保证在报文段的最大生存时间内没有重复的序号。
TCP 的序号字段为 32 位。

 ### <5-70> 假定用TCP协议在40Gbit/s的线路上传送数据。
(!)如果 TCP 充分利用了线路的带宽，那么需要多长的时间TCP会发生序号绕回?
(2)假定现在TCP的首部中采用了时间戳选项。时间戳占用了4字节，共32位。每隔一定的时间(这段时间叫做一个嘀咯)时间戳的数值加1。假定设计的时间戳是每隔859微秒，时间戳的数值加1。试问要经过多少时间才发生时间戳数值的绕回?
解答:分述如下:
(1)40Gbit/s的线路上传送数据，每秒可传送5X10$^9$字节的数据。TCP的序号字段有32位，共有2$^{32}$个不同序号，可以发送的时间是2$^{32}$/5000000000=0.859s=859ms即经过859ms后序号就绕回，又重复以前的数值。
(2)时间戳数值绕回的时间是2$^{32}$X859X10$^{-6}$=3.69X10$^6S$=42.7天，比原来的绕回时间大大增加了。
现在每一个TCP的数据报文段在其首部有两个字段用来标志这个报文段。一个是序号，另一个是时间戳。但发送方发送了2$^{32}$个字节的数据后，序号又绕回到初始的数值了，但这时的时间戳还没有绕回(因为在本例中，这需要经过42.7天才绕回)，而是指在某个数值，这和一开始的时间戳初始值肯定是不一样的。这样，即使序号一样，接收方也能够根据时间戳判断这是一个新的数据报文段，而不是以前发送过的旧的数据报文段。


### <5-71 > 在教材上 5.5 节中指出:例如，若用 2.5Gbit/s 的速率发送报文段，则不到 14 秒钟序号就会重复。请计算验证这句话 。
解答: 在2.5Gbit/s的线路上传送数据，每秒可传送0.3125X 10$^9$字节的数据。 TCP 报文段的序号字段有 32 位，共有 2^${32}$个不同序号，可以发送的时间是2$^32$/ 312500000 = 13.74s 也就是不到 14 秒钟数据字节的序号就会重复 。

### 【5-72】已知 TCP 的接收窗口大小是 600 (单位是字节，为简单起见以后就省略了单位)， 已经确认了的序号是 300。试问，在不断地接收报文段和发送确认报文段的过程 中，接收窗口也可能会发生变化(增大或缩小)。请用具体例子(指出接收方发
送的确认报文段中的重要信息)来说明哪些情况是可能发生的，而哪些情况是不允许发生的 。
解答:(1) 这是题目开始的情况。接收方发送的确认报文段中的接收窗口 rwnd = 600。已确认的 序号是 300。接收方发送的确认报文段的 ack=301. 表示期望收到开始的序号为 301 的数据。 我们看到，序号 301 到 900 都在接收窗口内 。
(2) 接收窗口增大总是不受限制的。这就是说，只要接收端的 TCP 能够拿出更多的空间 来接收发来的数据，就可以这样做。图中给出的例子是:已确认的序号是 400, 接收方发送 的确认报文段的 ack = 401 。假定现在接收窗口从情况 (1)的 600 增大到了 700, 即 rwnd = 700。 现在接收窗口的范围是从 401 到 1100。当接收窗口增大时，接收窗口的前沿总是向前移动的。
(3) 这种情况是接收窗口变小了，但接收窗口的前沿没有变化。例如，现在已确认的序号 是 400, 接收方发送的确认报文段的 ack = 401 。假定现在接收窗口从情况 (1)的 600 减小到了 500, 即 rwnd = 500。 接收窗口的范围是从 401 到 900。
(4) 这种情况是接收窗口变小了，同时接收窗口的前沿也向前移动了 。 例如，现在已确认 的序号是 500, 接收方发送的确认报文段的 ack = 501 。假定现在接收窗口从情况 (1)的 600 减 小到了500, 即rwnd=500。 接收窗口的范围是从501到1000。
(5) 这种情况是接收窗口变小了，但接收窗口的前沿是向后退的 。 例如，现在已确认的序 号是 500, 接收方发送的确认报文段的 ack= 501。 假定现在接收窗口从情况(1)的 600 减小到了 300, 即 rwnd = 300。接收窗口的范围是从 501 到 800。 但请注意，这种情况是不允许出现的。 也就是说，接收窗口的前沿是不允许后退的 。 在开始时，接收窗口的前沿的编号是 900。不管 接收窗口是变大还是变小，这个窗口的前沿的编号可以不动，也可以前移，但是不允许后退。为什么不允许出现这种情况呢?可以先观察 一 下发送方的情况。在 一 开始，发送方收到 接收窗口 =600 的报文段后(其中 ack=301), 发送方就把发送窗口设置为 600, 可以发送的 数据的序号从 301 到 900。假定发送方发送了在发送窗口内的全部数据。这本来正好落入到 接收窗口之内。但这些数据正在网络中传输时，接收方却缩小了接收窗口，只接收序号从 501 到 800 之间的数据 。这 就导致最 后的-些数据(编 号从 801 到 900) 落到接收窗口之外了， 使得接收方只能丢弃这些数据(编号从 801 到 900)。 因此，这种情况(在发送时数据是在发送窗口之内，但当到达接收端时，这些数据却落到接收窗口之外)必须避免 。总之 ，我们要记住，接收窗口的前沿是不允许后退的。

### 【5-73】在上题中，如果接收方突然因某种原因不能够再接收数据了，可以立即向发送方发送把接收窗口置为零的报文段(即rwnd=0)。这时会导致接收窗口的前沿后退。试问这种情况是否允许?
解答:这种情况是允许的。当发送方收到这样的信息时，并不是把发送窗口缩回到零，而是立即停止发送。什么时候可以再发送数据，就要等接收方重新开放接收窗口，即给出一个非零的接收窗口。详细的过程见本章的常见问题与解答5-10的持续计时器部分。

### <5-74 > 流量控制和拥塞控制的最主要的区别是什么?发送窗口的大小取决千流量控 制还是拥塞控制?
解答:简单地说，流量控制是在一条 TCP 连接中的接收端采用的措施，用来限制对方(发送端)发送报文段的速率，以免在接收端来不及接收。流量控制只控制一个发送端。
拥塞控制是用来控制 TCP 连接中发送端发送报文段的速率，以免使互联网中的某处产生过载。拥塞控制可能会同时控制许多个发送端，限制它们的发送速率。不过每一个发送端只知道自己应当怎样调整发送速率，而不知道在互联网中还有哪些主机被限制了发送速率。
我们知道，**发送窗口的上限值是 Min [rwnd, cwnd], 即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个 **。接收窗口的大小体现了接收端对发送端施加的流量控制，而拥塞窗口的大小则是整个互联网的负载情况对发送端施加的拥塞控制。因此，当接收窗口小千拥塞窗口时，发送窗口的大小取决于流量控制，即取决千接收端的接收能力。但当拥塞窗口小千接收窗口时，则发送窗口的大小取决千拥塞控制，即取决于整个网络的拥塞状况。


### *【5-75】假定在 TCP 连接中刚刚收到的最新的往返时间 RTT 是 1 秒，那么超时重传时间 RTO 是否应当设置成大于或等千 1 秒?
解答: 这不一定。超时重传时间 RTO 应当根据教材上的公式(5-4)和(5-5)来计算，而不是 根据某 一个 RTT 样本来计算 。如果仅根据一个 RTT 样本就确定了超时重传时间 RTO, 那么 RTO 的数值就可能会经常大幅度地波动。这就会使超时重传时间 RTO 的数值很不准确，使 TCP 的传输性能变坏。

### *< 5-76 >在教材附录 C[KUR013]中的运输层这一章给出了 TCP 连接的平均吞吐量 R 的 公式如下:R= 0.75 W / RTT 这里的RTT是往返时间， W是发生报文段丢失时的拥塞窗口值。 试推导上面的公式，并给出必要的假设条件。这里的吞吐量指的是每秒发送的数据字节(不包括首部)。
解答:推导这个公式需要有 三个假定条件:
 (1) 忽略在超时事件后(即网络开始拥塞并引起报文段的丢失)的慢开始阶段 。 做出这样 的假定是合理的，因为慢开始阶段通常都非常短，发送方很快就会离开慢开始阶段(发送的 报文段以指数增长方式进入网络)。但 TCP 的拥塞窗口增长到门限值 ssthresh 的一半时就进入 拥塞避免阶段，拥塞窗口每经过一个传输轮次就加 1 个 MSS。
 (2) 假定当拥塞窗口值到达 WE 这也就是门限值 ssthresh 的数值)时，发生报文段的丢失(而在这以前都没有发生报文段的丢失)，并且每次都是当拥塞窗口值到达 W 时就发生报文 段的丢失。在实际的互联网中，发生报文段丢失时的拥塞窗口值应当是在变化的，这是由千 整个网络的拥塞情况，取决千分布在各地的所有用户的行为。一个用户无法知道其他用户在 什么时候向网络注入大量的数据。但为了简化计算，只好假定拥塞窗口的数值在整个 TCP 连 接期间都不变化，都是恒定的值 WE 即门限值 ssthresh 的数值)。
 (3) 假定在整个 TCP 连接期间，每 一个 传输轮次的 RTT 时间都是不变的。例如，在某一 个传输轮次，拥塞窗口是 4 个 MSS, 那么 RTT 值就是发送方连续发送 4 个报文段，并收到对 方对最后一个字节的确认所经历的时间。下一个轮次拥塞窗口就增加到 5。这时的 RTT 值是 发送方连续发送 5 个报文段，并收到对方对最后一个字节的确认所经历的时间。这个 RTT 显 然应当会有变化。但为了分析的方便，我们假定所有的 RTT 值都是恒定不变的。当连续发送 的报文段的数目较多，发送速率较高而传播距离较远时，这样的假定还是合理的。
有了这三个假定，我们就可得出拥塞窗口变化的情况如图 T-5-76所示。
在每一个拥塞避免阶段刚开始时，拥塞窗口的数值是 W 的一半，即 0.5W。因此在往返时间 RTT 内可以发送的数据字节数是 0.5W字节。这样就得出 TCP 在这段往返时间的吞吐量(这是吞吐量的最小值)，它等千 0.5WI RTT。
以后每隔一个传输轮次，拥塞窗口就加 1 个 MSS 。这样 ，拥塞窗口线性地增加到 W 时再次发生报文段的丢失。 TCP 又进入到下一轮的拥塞避免。因此， TCP 的在最后这段往返时间的吞吐量(每秒发送的数据字节数)达到最大值，即 WIRTT。
由于 TCP 吞吐量是线性增长的，因此 TCP 连接的平均吞吐量 R 是吞吐量的最小值和最大值之和的一半，即
R=[(0.5+ 1)/2]W / RTT=0.75W/RTT


### *< 5-79 > TCP 对拥塞控制采用的是动态调整的策略 。能否给出动态调整的要点?
解答: TCP 的拥塞控制的动态调整策略的要点有以下三个。
(I) 探测网络的拥塞水平。慢开始就是从发送一个报文段开始探测网络的。
(2) 如果网络没有拥塞，就加快发送速率。在慢开始和拥塞避免阶段都是这样。
(3) 如果网络发生了拥塞，就降低发送速率。例如，回到慢开始，或让门限值 ssthresh 减半。

 ### <5-80 > 请用框图的表示方法来说明 TCP 的拥寒控制流程。
 解答:图 T-5-80 给出了 TCP 的拥塞控制流程图 。
整个的流程图可分为二大阶段，即慢开始阶段、拥塞避免阶段和出现拥塞阶段。出现拥塞阶段在图中是最下方的虚线框，里面分为两种不同的情况，一种是出现超时，另一种是收到了 3 个重复的确认 ACK。
这里应当强调的是，当网络出现拥塞时，并没有一个什么机构来通知发送端使其降低发送速率。发送端探测网络是否发生了拥塞是根据能否及时收到对方发来的确认。如果出现了超时(就是在设定的时间内收不到对方发来的确认)，就说明发生了报文段的丢失。 TCP 认为， 报文段的丢失就是网络发生拥塞的重要信号。因此，不管 TCP 处在哪一个阶段(慢开始阶段或拥塞避免阶段)，只要出现超时，就要把慢开始阶段的门限值 ssthresh 减半，然后就进入慢开始阶段。拥塞窗口从 1 开始逐渐增大。
但有时还没有到超时重传的时候，就收到了重复的确认 ACK。收到了重复的 ACK 表明某个报文段没有到达接收端，但它后续的报文段却到达了。这就有两种可能性:一种是这个报文段是在途中的某个路由器处排队耽误了一些时间，过些时间就会到达接收端;而另一种可能性是这个报文段已经丢失了，以后也不会到达接收端。TCP认为，如果只收到了一个或两个重复的ACK,那么这个报文段还可能没有丢失，还应当再等待一下。但是，如果一连收到了3个重复的ACK,那么就应当认为这个报文段大概是丢失了。于是立即重传这个报文段，并把门限值减半，然后进入拥塞避免阶段。为什么报文段丢失了还不进入慢开始阶段呢?这是因为，虽然发生了报文段的丢失，但并没有出现超时，而且接收端还能够连续收到3个重复的ACK。这表明虽然出现了拥塞，但拥塞的程度并不像出现超时那样严重。因此，TCP没有必要从一个报文段开始发送，而是可以在拥塞窗口减半的基础上把更多的报文段注入到网络中。
