- [问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?](#问题-5-1-tcp-协议是面向连接的但-tcp-使用的-ip-协议却是无连接的这两种协议都-有哪些主要的区别)
- [问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?](#问题5-2-从通信的起点和终点来比较-tcp和ip的不同点是什么)
- [问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么?](#问题-5-3-ip和-udp-的一个共同点就是它们都是无连接-的-ip和-udp-最主要的区别是什么)
- [问题 5-4. 端口(port)和套接字(socket)的区别是什么?](#问题-5-4-端口port和套接字socket的区别是什么)
- [问题 5-5 一 个套接字能否同时与远地的两个套接字相连?](#问题-5-5-一-个套接字能否同时与远地的两个套接字相连)
- [问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?](#问题5-6数据链路层的hdlc协议和运输层的tcp协议都使用滑动窗口技术从这方面来进行比较数据链路层协议和运输层协议的主要区别是什么)
- [问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?](#问题5-7tcp协议能够实现可靠的端到端传输在数据链路层和网络层的传输还有没有必要来保证可靠传输呢)
- [问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?](#问题5-8在tcp报文段的首部中只有端口号而没有ip地址当tcp将其报文段交给ip层时ip协议怎样知道目的ip地址呢)
- [问题5-9在TCP传送数据时，有没有规定一个最大重传次数?](#问题5-9在tcp传送数据时有没有规定一个最大重传次数)
- [问题5-10.TCP都使用哪些计时器?](#问题5-10tcp都使用哪些计时器)
- [问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?](#问题-5-11-是否-tcp-和-udp-都需要计算往返时间-rtt)
- [问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?](#问题5-12假定tcp开始进行连接建立当tcp发送第一个syn报文段时显然无法利用教材中562节所介绍的方法计算往返时间rtt那么这时tcp又怎样设置重传计时器呢)
- [问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?](#问题-5-13-糊涂窗口综合征产生的条件是什么是否只有在接收方才产生这种症状)
- [问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?](#问题-5-14-能否更详细地讨论-一-下糊涂窗口综合征及其解决方法)
- [问题 5-15 为什么TCP什让汒连接盯小能每次都选择相同的、固定的初始序号?](#问题-5-15-为什么tcp什让汒连接盯小能每次都选择相同的固定的初始序号)
- [问题 5-16. 能否利用 TCP 发送端和接收端交换报文段的图来说明慢开始的特点?](#问题-5-16-能否利用-tcp-发送端和接收端交换报文段的图来说明慢开始的特点)
- [问题 5-17. 对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理?](#问题-5-17-对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理)
### 问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?
解答:这个问题很重要，一定要弄清楚。
TCP 是面向连接的，但TCP所使用的网络则可以是面向连接的(如X.25网络)，但也可以是无连接的(如现在大量使用的IP网络)。选择无连接网络就使得整个系统非常灵活，当然也带来了一些问题。
显然，TCP提供的功能和服务要比IP所能提供的多得多。这是因为TCP使用了诸如确认、窗口通知计时器笘机制，因而可以检测出有差错的报文、重复的报文和失序的报文。

### 问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?
解答: 
进程A和进程B的通信是使用面向连接的TCP提供的可靠的传输。
主机X和主机Y的通信是使用无连接的IP提供的不可靠的传输。
请注意:对TCP来说，通信的起点和终点是运输层上面的两个**套接字(socket)**,而应用层的应用进程正是通过应用层和运输层之间的套接字来使用TCP提供的服务。TCP协议根据报文段首部中的端口号找到目的端口，将报文段交付**目的进程**。请注意:套接字是由IP地址和端口号决定的，套接字也可称为“插口”。
对IP来说，通信的起点和终点是连接在网络上的两个**主机**。IP协议根据数据报首部中的目的IP地址找到目的主机，将数据报交付**目的主机**。
请注意可靠传输的范围和不可靠传输的范围是不同的 。
我们还应当注意的是:虽然在两个套接字之间的通信是面向连接的，但IP数据报在下面的网络中传输时是独立地选择路由，而**不是沿着某—条固定的路径传输**。然而在上面的端口看来，TCP报文段**好像都是从一个虚拟的、可靠的通信管道中传输到对方的端口的。**

### 问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么? 
解答: IP是**主机到主机**的通信协议，但UDP是**进程到进程**的通信协议。

### 问题 5-4. 端口(port)和套接字(socket)的区别是什么?
解答: 从教材经常使用的套接字定义来看，套接字包含了端口，因为**套接字**=(IP地址，端口号)。套接字是TCP连接的端点。套接字又称为"插口”。
但我们已经讲过，套接字(socket)有多种意思。当使用API时，套接字往往被看成是操作系统的一种抽象，这时，套接字和一个文件描述符是很相似的，并且是应用编程接口API的一部分。套接字由应用程序产生，并指明它将由客户还是服务器来使用。当应用进程创建一个套接字时，要指明该套接字使用的瑞门号。
**端口**则是应用层服务的一种代号，它用来标志应用层的进程。端口是一个16bit的整数。各种服务器使用的湍口号都是保留端口号，以便使客户能够找到服务器。例如万维网服务器使用的端口号是80。
在发送数据时，应用层的数据通过端口向下交付运输层。在接收数据时，运输层的数据通过适当的端口向上交付应用层的某个应用程序。

### 问题 5-5 一 个套接字能否同时与远地的两个套接字相连?
解答:不行。一个套接字只能和另一个远地套接字相连。
如果许多个客户同时访问同一个服务器，那么对千这种情况，请参考教材第6章图6~30及相应的文字解释。

### 问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?
解答:运输层的TCP协议是端到端(进程到进程)的协议，而数据链路层的HDLC协议则是仅在一段链路上的结点到结点的协议。此外，TCP的窗口机制和HDLC的也有许多区别。如TCP是按数据部分的字节数进行确认的，而HDLC则是以帧为确认的单位。需要注意的是，现在使用得最多的PPP链路层协议并不使用确认机制和窗口机制。因此像PPP协议这样的链路层协议就和运输层协议有相当大的区别 。

### 问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?
解答:在旧的OSI体系中，在数据链路层使用HDLC协议而在网络层使用X.25协议，这些协议都有确认机制和窗口机制，因而能够保证可靠传输。但是技术的进步使得链路的传输已经相当可靠了，因此在数据链路层和网络层重复地保证可靠传输就显得多余了。现在互联网在链路层使用的PPP协议和在网络层使用的IP协议都没有确认机制和窗口机制。如果出现差错就由运输层的TCP来处理(若使用UDP协议则运输层也不处理出错的问题)。

### 问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?
解答:显然，仅从TCP报文段的首部无法得知目的IP地址。因此，TCP必须告诉IP层此报文段要发送给哪一个目的主机(给出其IP地址)。此目的IP地址填写在IP数据报的首部中。

### 问题5-9在TCP传送数据时，有没有规定一个最大重传次数?
解答:我们知道以太网规定重传16次就认为传输失败，然后报告上层。但TCP没有规定最大重传次数，而是通过设置一些计时器来解决有关传输失败的问题。

### 问题5-10.TCP都使用哪些计时器?
解答:TCP共使用以下四种计时器，即重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下。
**重传计时器**
当 TCP 发送报文段时，就创建该特定报文段的重传计时器。可能发生两种情况:
(I) 若在计时器截止时间到来之前收到了对此特定报文段的确认，则撤销此计时器。
(2) 若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。
**持续计时器**
为了对付零窗口大小通知， TCP 需要另 一个计 时器。假定“接收 TCP" 给出了窗口大小 为零，“发送 TCP"就停止传送报文段，直到“接收TCP"发送确认并给出一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认报文段是不发送确认的。若确认丢失了，“接收TCP"并不知道，而是会认为它已经完成任务了，并等待着“发送TCP"接着会发送更多的报文段。但“发送TCP"由千没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。
要打开这种死锁，TCP为每一个连接使用一个待续计时器。当“发送TCP"收到一个窗口大小为零的确认时，就启动持续计时器。当持续计时器期限到时，“发送TCP"就发送一个特殊的报文段，叫做探测报文段。这个报文段只有一个字节的数据。它有一个序号，但它的序号永远不需要确认;甚至在计算对其他部分的数据的确认时，该序号也被忽略。探测报文段提醒接收TCP:确认已丢失，必须重传。
待续计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将待续计时器的值加倍和复位。发送端继续发送探测报文段，将持续计时器设定的值加倍和复位，直到这个值增大到门限值(通常是60秒)为止。在这以后，发送端每隔 60 秒就发送一个探测报文段，直到窗口重新打开。
**保活计时器**
保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保待静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处千打开状态。
要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段(每一个相隔75秒)还没有响应，就假定客户出了故障，这时就终止该连接。
**时间等待计时器**
时间等待计时器是在连接终止期间使用的。当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间，连接还处千一种中间过渡状态。这就可以使重复的FINC终止)报文段(如果有的话)可以到达目的站，从而可将其丢弃。这个计时器的值通常设置为一个报文段的寿命期待值的两倍。


### 问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?
解答:往返时间RTT只是对运输层的TCP协议才很重要，因为TCP要根据平均往返时间RTT的值来设置超时计时器的超时时间。
UDP没有确认和重传机制，因此RTT对UDP没有什么意义。
所以，不要笼统地说“往返时间RTT对运输层来说很重要“，因为只有TCP才需要计算RTT,而UDP不需要计算RTT。

### 问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?
解答:这时TCP显然无法利用已有的公式算出往返时间RTT。实际上TCP是选择(也就是猜测)一个比较长的时间作为初始的往返时间RTT。等到收到至少一个确认报文段时，才能利用公式计算出比较合理的往返时间 RTT。

### 问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?
解答: 糊涂窗口综合征产生的条件是: 当发送应用程序产生数据很慢，或接收应用程序读取数据(或消耗数据)很慢，或者两者都有。这时发送方和接收方都可能产生这种症状。
不管是上述情况中的哪一种，都使得发送数据的报文段很小，这就引起操作效率的降低。例如，若TCP发送的报文段只包括一个字节的数据，则意味着我们发送41字节的数据报(20字节的TCP首部和20字节的IP首部)才传送1字节的数据。数据的传送效率是1/41,它表示我们在非常低效率地使用网络的容量。

### 问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?
解答 :详细讨论如下。
**发送端产生的症状**
如果发送端为产生数据很慢的应用程序服务，例如，一次产生一个字节。这个应用程序一次将一个字节的数据写入发送端的TCP的缓存。如果发送端的TCP没有特定的指令，它就产生只包括一个字节数据的报文段。结果有很多41字节的IP数据报就在互联网中传来传去。
解决的方法是防止发送端的TCP逐个字节地发送数据。必须强迫发送端的TCP收集数据，然后用一个更大的数据块来发送。发送端的TCP要等待多长时间呢?如果等待时间过长，它就会使整个过程产生较长的时延。如果等待时间不够长，它就可能发送较小的报文段。Nagle找到了一个很好的解决方法。
**Nagle算法**
Nagle算法非常简单，但它能解决问题。这个算法是为发送端的TCP用的:
(I)发送端的TCP将它从发送应用程序收到的第一块数据发送出去，哪怕只有一个字节。(2)在发送第一个报文段(即报文段I)以后，发送端的TCP就在输出缓存中积累数据，
并等待:或者接收端的TCP发送出一个确认，或者数据已积累到可以装成一个最大的报文段，在这个时候，发送端的TCP就可以发送这个报文段。
(3)对剩下的传输，重复步骤2。这就是:如果收到了对报文段x的确认，或者数据已积累到可以装成一个最大的报文段时，那么就发送下一个报文段(x+1)。
Nagle算法的优点就是简单，并且它考虑到应用程序产生数据的速率，以及网络运输数据的速率。若应用程序比网络更快，则报文段就更大(最大报文段)。若应用程序比网络慢，则报文段就较小(小于最大报文段)。
**接收端产生的症状**
接收端的TCP可能产生糊涂窗口综合征，如果它为消耗数据很慢的应用程序服务，例如，一次消耗一个字节。假定发送应用程序产生了1000字节的数据块，但接收应用程序每次只读取1字节的数据。再假定接收端的TCP的输入缓存为4000字节。发送端先发送第一个4000字节的数据。接收端将它存储在其缓存中。现在缓存满了。接收端的TCP就通知窗口大小为零，这表示发送端必须停止发送数据。接收应用程序从接收端的TCP的输入缓存中读取第一个字节的数据。这时在输入缓存中就有了1字节的空间。接收端的TCP宣布其窗口大小为1字节，这表示正渴望等待发送数据的发送端的TCP会把这个宣布当作一个好消息，并发送只包括一个字节数据的报文段。这样的过程一直继续下去。一个字节的数据被消耗掉，然后再发送只包含一个字节数据的报文段。这又是一个低效率问题和糊涂窗口综合征(见图Q-5-14)
对于这种糊涂窗口综合征，即应用程序消耗数据比到达的慢，有两种建议的解决}」法。
**Clark解决方法**
Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，自到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。
**延迟的确认**
第二个解决方法是延迟一段时间后再发送确认。这表示当一个报文段到达时并不立即发送确认。接收端在确认收到报文段之前一直等待，直到缓存有足够的空间为止。延迟的确认防止了发送端的TCP滑动其窗口。当发送端的TCP发送完其数据后，它就停下来了。这样就防止了这种糊涂窗口综合征。
迟延的确认还有另一个优点:它减少了通信量。接收端不需要确认每一个报文段。但它也有一个缺点，就是迟延的确认有可能迫使发送端重传其未被确认的报文段。
可以用协议来平衡这个优点和缺点，例如，现在定义了确认的延迟不能超过500毫秒。

### 问题 5-15 为什么TCP什让汒连接盯小能每次都选择相同的、固定的初始序号?
解答:如果TCP在建立连接时每次都选择相同的、固定的初始序号，那么设想以下的情况:
(1)假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。
(2)假定每一次建立连接时，主机A都选择相同的、固定的初始序号，例如，选择l。
(3)假定主机A发送出的某些TCP报文段在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段。
(4)假定有一些在网络中滞留时间较长的TCP报文段最后终于到达了主机B,但这时传送该报文段的那个连接早已释放了，而在到达主机B时的TCP连接是一条新的TCP连接。这样，工作在新的TCP连接下的主机B就有可能会接受在旧的连接传送的、已经没有意义的、过时的TCP报文段(因为这个TCP报文段的序号有可能正好处在现在新的连接所使用的序号范围之中)，结果产生错误。
因此，必须使得迟到的TCP报文段的序号不处在新的连接中所使用的序号范围之中。
这样，TCP在建立新的连接时所选择的初始序号，一定要和前面的一些连接所使用过的序号不一样。所以，不同的TCP连接不能使用相同的初始序号。

### 问题 5-16. 能否利用 TCP 发送端和接收端交换报文段的图来说明慢开始的特点? 
解答:慢开始的特点可以用图 Q-5-16 来说明。
拥塞窗口cwnd的初始值是1(为方便起见，这里将拥塞窗口的单位设为报文段)。以后**每收到一个对新的报文段的确认，就将发送端的拥塞窗口cwnd加1。**
从图Q-5-16可以看出，拥塞窗口cwnd按照指数规律增长。所谓“新的报文段”就是指“未被确认过的报文段"。由千报文段在互联网中传输时，有可能在某个路由器处滞留一段时间，但以后又被交付接收端(重复交付)。接收端对每一个收到的无差错的报文段都可能给出确认。因此，对同一个报文段，发送端有可能收到几个重复的确认。但除了第一个确认可以使发送端拥塞窗口cwnd加1以外，对其余重复的报文段的确认都不能再使发送端拥塞窗口加1。


### 问题 5-17. 对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理?
解答:可以，但这只能是示意图。
因为在拥塞避免的开始，发送端的拥塞窗口 swnd=ssthresh,这时可以发送好几个报文段。 按照 RFC 2581 文档，每经过一个往返时间 RTT, 拥塞窗口就增加一个 MSS (最大报文段长 度)的大小(以字节为单位)。
在我们讨论原理时，以报文段个数作为窗口单位较为方便，因此在图 Q-5-17 中每经过一 个 RTT, 发送端拥塞窗口 swnd 就在 ssthresh 的基础上加1。
在图 Q-5-17 中将发送端发送报文段用一个粗箭头表示(因为这里面包含有许多个报文段， 很难一个个画出)，确认报文段也用一个粗箭头表示(这也可能有许多个确认报文段)，因此RTT也是概念性的往返时间。

