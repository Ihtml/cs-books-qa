- [问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?](#问题-5-1-tcp-协议是面向连接的但-tcp-使用的-ip-协议却是无连接的这两种协议都-有哪些主要的区别)
- [问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?](#问题5-2-从通信的起点和终点来比较-tcp和ip的不同点是什么)
- [问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么?](#问题-5-3-ip和-udp-的一个共同点就是它们都是无连接-的-ip和-udp-最主要的区别是什么)
- [问题 5-4. 端口(port)和套接字(socket)的区别是什么?](#问题-5-4-端口port和套接字socket的区别是什么)
- [问题 5-5 一 个套接字能否同时与远地的两个套接字相连?](#问题-5-5-一-个套接字能否同时与远地的两个套接字相连)
- [问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?](#问题5-6数据链路层的hdlc协议和运输层的tcp协议都使用滑动窗口技术从这方面来进行比较数据链路层协议和运输层协议的主要区别是什么)
- [问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?](#问题5-7tcp协议能够实现可靠的端到端传输在数据链路层和网络层的传输还有没有必要来保证可靠传输呢)
- [问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?](#问题5-8在tcp报文段的首部中只有端口号而没有ip地址当tcp将其报文段交给ip层时ip协议怎样知道目的ip地址呢)
- [问题5-9在TCP传送数据时，有没有规定一个最大重传次数?](#问题5-9在tcp传送数据时有没有规定一个最大重传次数)
- [问题5-10.TCP都使用哪些计时器?](#问题5-10tcp都使用哪些计时器)
- [问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?](#问题-5-11-是否-tcp-和-udp-都需要计算往返时间-rtt)
- [问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?](#问题5-12假定tcp开始进行连接建立当tcp发送第一个syn报文段时显然无法利用教材中562节所介绍的方法计算往返时间rtt那么这时tcp又怎样设置重传计时器呢)
- [问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?](#问题-5-13-糊涂窗口综合征产生的条件是什么是否只有在接收方才产生这种症状)
- [问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?](#问题-5-14-能否更详细地讨论-一-下糊涂窗口综合征及其解决方法)
- [问题 5-15 为什么TCP什让汒连接盯小能每次都选择相同的、固定的初始序号?](#问题-5-15-为什么tcp什让汒连接盯小能每次都选择相同的固定的初始序号)
- [问题 5-16. 能否利用 TCP 发送端和接收端交换报文段的图来说明慢开始的特点?](#问题-5-16-能否利用-tcp-发送端和接收端交换报文段的图来说明慢开始的特点)
- [问题 5-17. 对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理?](#问题-5-17-对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理)
- [问题 5-18. TCP连接很像一条连接发送端和接收端的双向管道。当 TCP在连续发送报文段时，若要管道得到充分的利用，则发送窗口的大小应怎样选择?](#问题-5-18-tcp连接很像一条连接发送端和接收端的双向管道当-tcp在连续发送报文段时若要管道得到充分的利用则发送窗口的大小应怎样选择)
- [问题5-19. 假定在一个互联网中，所有的链路的传输都不出现差错，所有的结点也都不会发生故障。试间在这种情况下， TCP 的”可靠交付"的功能是否就是多余的?](#问题5-19-假定在一个互联网中所有的链路的传输都不出现差错所有的结点也都不会发生故障试间在这种情况下-tcp-的可靠交付的功能是否就是多余的)
- [问题5-20. TCP是通信协议还是软件?](#问题5-20-tcp是通信协议还是软件)
- [问题5-21.在计算TCP的往返时间RTT的公式中，《计算机网络》教材过去的版本是取a=7/8。但在第6版和第7版中是取a=1/8。为什么会有这样大的改变?](#问题5-21在计算tcp的往返时间rtt的公式中计算机网络教材过去的版本是取a78但在第6版和第7版中是取a18为什么会有这样大的改变)
- [问题 5-22 假定有一个应用程序需要知道报文从发送端到接收端所经受的时延。能否这样计算:从TCP获得往返时间RTT的数值。然后除以2?](#问题-5-22-假定有一个应用程序需要知道报文从发送端到接收端所经受的时延能否这样计算从tcp获得往返时间rtt的数值然后除以2)
- [问题 5-23. 教材上的图 5-7 在计算 UDP 检 验和时，为什么有的读者算出的“求和得出的 结果”是 1001011011101011, 而不是教材上给出的 10010110 1110110I?](#问题-5-23-教材上的图-5-7-在计算-udp-检-验和时为什么有的读者算出的求和得出的-结果是-1001011011101011-而不是教材上给出的-10010110-1110110i)
- [问题 5-24. TCP 的客户端和服务器端在交换数据时，为什么不含数据的确认报文段不消耗序号呢?](#问题-5-24-tcp-的客户端和服务器端在交换数据时为什么不含数据的确认报文段不消耗序号呢)
- [问题 5-25. TCP 在连接建立时所发送的第一个 SYN 报文段只有首部，其数据部分是空的。 但为什么 SYN 报文段要消耗一个序号呢?](#问题-5-25-tcp-在连接建立时所发送的第一个-syn-报文段只有首部其数据部分是空的-但为什么-syn-报文段要消耗一个序号呢)
- [问题 5-26. TCP 在连接建立时，A发送SYN报文段，选择了初始序号seq=x。B收到连接请求报文段后，如同意建立连接，则向A发送确认和SYN报文段，其确认号是ack = x + 1, 同时也为自己选择一个初始序号 seq=y。 A 最后要发送确认报文段， 其序号是 seq= x + 1, 确认号是 ack = y + I 。这个确认 报文段消耗序号吗?](#问题-5-26-tcp-在连接建立时a发送syn报文段选择了初始序号seqxb收到连接请求报文段后如同意建立连接则向a发送确认和syn报文段其确认号是ack--x--1-同时也为自己选择一个初始序号-seqy-a-最后要发送确认报文段-其序号是-seq-x--1-确认号是-ack--y--i-这个确认-报文段消耗序号吗)
- [问题 5-27. TCP 连接建立采用的 Three-Way Handshaking 的准确译名应当是怎样的?](#问题-5-27-tcp-连接建立采用的-three-way-handshaking-的准确译名应当是怎样的)
- [问题 5-28. TCP 报文段的长度有没有规定的最小值和最大值?](#问题-5-28-tcp-报文段的长度有没有规定的最小值和最大值)
- [问题 5-29. 能否这样讲:当我们在互联网上传送很长的大文件时，就必须使用 TCP 协议 而不是使用 UDP 协议?](#问题-5-29-能否这样讲当我们在互联网上传送很长的大文件时就必须使用-tcp-协议-而不是使用-udp-协议)
- [习题与解答](#习题与解答)
- [【5-01 】 试说明运输层在协议栈中的地位和作用。运输层的通信和网络层的通信有什么 重要的区别?为什么运输层是必不可少的?](#5-01--试说明运输层在协议栈中的地位和作用运输层的通信和网络层的通信有什么-重要的区别为什么运输层是必不可少的)
- [<5-02 > 网络层提供数据报或虚电路服务，对上面的运输层有何影响?](#5-02--网络层提供数据报或虚电路服务对上面的运输层有何影响)
- [<5-03 > 当应用程序使用面向连接的 TCP 和无连接的IP时，这种传输是面向连接的还是无连接的?](#5-03--当应用程序使用面向连接的-tcp-和无连接的ip时这种传输是面向连接的还是无连接的)
- [【5-04】试画图解释运输层的复用。画图说明许多个运输用户复用到 一 条运输连接上， 而这条运输连接又复用到 IP 数据报上。](#5-04试画图解释运输层的复用画图说明许多个运输用户复用到-一-条运输连接上-而这条运输连接又复用到-ip-数据报上)
- [【5-05】试举例说明有些应用程序愿意采用不可靠的 UDP, 而不愿意采用可靠的 TCP。](#5-05试举例说明有些应用程序愿意采用不可靠的-udp-而不愿意采用可靠的-tcp)
- [<5-06 > 接收方收到有差错的 UDP 用户数据报时应如何处理?](#5-06--接收方收到有差错的-udp-用户数据报时应如何处理)
- [<5-07> 如果应用程序愿意使用 UDP 完成可靠传输，这可能吗?请说明理由 。](#5-07-如果应用程序愿意使用-udp-完成可靠传输这可能吗请说明理由-)
- [<5-08> 为什么说 UDP 是面向报文的，而 TCP 是面向字节流的?](#5-08-为什么说-udp-是面向报文的而-tcp-是面向字节流的)
- [<5-09 > 端口的作用是什么?为什么端口号要划分为三种?](#5-09--端口的作用是什么为什么端口号要划分为三种)
- [<5-10 > 试说明运输层中伪首部的作用 。](#5-10--试说明运输层中伪首部的作用-)
- [【5-11 】 某个应用进程使用运输层的用户数据报UDP,然后继续向下交给IP层后，又封装成IP数据报。既然都是数据报，是否可以跳过UDP而直接交给IP层?哪些功能UDP提供了但IP没有提供?](#5-11--某个应用进程使用运输层的用户数据报udp然后继续向下交给ip层后又封装成ip数据报既然都是数据报是否可以跳过udp而直接交给ip层哪些功能udp提供了但ip没有提供)
- [【5-12】 一个应用程序用UDP,到了JP层把数据报再划分为4个数据报片发送出去。结果前两个数据报片丢失，后两个到达目的站。过了一段时间应用程序重传UDP,而IP层仍然划分为4个数据报片来传送。结果这次前两个到达目的站而后两个丢失。试问:在目的站能否将这两次传输的4个数据报片组装成为完整的数据报?假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中。](#5-12-一个应用程序用udp到了jp层把数据报再划分为4个数据报片发送出去结果前两个数据报片丢失后两个到达目的站过了一段时间应用程序重传udp而ip层仍然划分为4个数据报片来传送结果这次前两个到达目的站而后两个丢失试问在目的站能否将这两次传输的4个数据报片组装成为完整的数据报假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中)
- [【5-13】 一个 UDP 用户数据报的数据字段为 8192 字节。在链路层要使用以太网来传送。 试问应当划分为几个 IP 数据报片?说明每一个 IP 数据报片的数据字段长度和片偏移字段的值。](#5-13-一个-udp-用户数据报的数据字段为-8192-字节在链路层要使用以太网来传送-试问应当划分为几个-ip-数据报片说明每一个-ip-数据报片的数据字段长度和片偏移字段的值)
- [【5-14】 一个 UDP 用户数据报的首部的十六进制表示是: 06 32 00 45 00 1C E2 17。试 求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报 是从客户发送给服务器还是从服务器发送给客户?使用 UDP 的这个服务器程序是什么?](#5-14-一个-udp-用户数据报的首部的十六进制表示是-06-32-00-45-00-1c-e2-17试-求源端口目的端口用户数据报的总长度数据部分长度这个用户数据报-是从客户发送给服务器还是从服务器发送给客户使用-udp-的这个服务器程序是什么)
- [【5-15】使用 TCP 对实时话音数据的传输有没有什么问题?使用 UDP 在传送数据文件时会有什么问题?](#5-15使用-tcp-对实时话音数据的传输有没有什么问题使用-udp-在传送数据文件时会有什么问题)
- [<5-16 > 在停止等待协议中，如果不使用编号是否可行?为什么?](#5-16--在停止等待协议中如果不使用编号是否可行为什么)
### 问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?
解答:这个问题很重要，一定要弄清楚。
TCP 是面向连接的，但TCP所使用的网络则可以是面向连接的(如X.25网络)，但也可以是无连接的(如现在大量使用的IP网络)。选择无连接网络就使得整个系统非常灵活，当然也带来了一些问题。
显然，TCP提供的功能和服务要比IP所能提供的多得多。这是因为TCP使用了诸如确认、窗口通知计时器笘机制，因而可以检测出有差错的报文、重复的报文和失序的报文。

### 问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?
解答: 
进程A和进程B的通信是使用面向连接的TCP提供的可靠的传输。
主机X和主机Y的通信是使用无连接的IP提供的不可靠的传输。
请注意:对TCP来说，通信的起点和终点是运输层上面的两个**套接字(socket)**,而应用层的应用进程正是通过应用层和运输层之间的套接字来使用TCP提供的服务。TCP协议根据报文段首部中的端口号找到目的端口，将报文段交付**目的进程**。请注意:套接字是由IP地址和端口号决定的，套接字也可称为“插口”。
对IP来说，通信的起点和终点是连接在网络上的两个**主机**。IP协议根据数据报首部中的目的IP地址找到目的主机，将数据报交付**目的主机**。
请注意可靠传输的范围和不可靠传输的范围是不同的 。
我们还应当注意的是:虽然在两个套接字之间的通信是面向连接的，但IP数据报在下面的网络中传输时是独立地选择路由，而**不是沿着某—条固定的路径传输**。然而在上面的端口看来，TCP报文段**好像都是从一个虚拟的、可靠的通信管道中传输到对方的端口的。**

### 问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么? 
解答: IP是**主机到主机**的通信协议，但UDP是**进程到进程**的通信协议。

### 问题 5-4. 端口(port)和套接字(socket)的区别是什么?
解答: 从教材经常使用的套接字定义来看，套接字包含了端口，因为**套接字**=(IP地址，端口号)。套接字是TCP连接的端点。套接字又称为"插口”。
但我们已经讲过，套接字(socket)有多种意思。当使用API时，套接字往往被看成是操作系统的一种抽象，这时，套接字和一个文件描述符是很相似的，并且是应用编程接口API的一部分。套接字由应用程序产生，并指明它将由客户还是服务器来使用。当应用进程创建一个套接字时，要指明该套接字使用的瑞门号。
**端口**则是应用层服务的一种代号，它用来标志应用层的进程。端口是一个16bit的整数。各种服务器使用的湍口号都是保留端口号，以便使客户能够找到服务器。例如万维网服务器使用的端口号是80。
在发送数据时，应用层的数据通过端口向下交付运输层。在接收数据时，运输层的数据通过适当的端口向上交付应用层的某个应用程序。

### 问题 5-5 一 个套接字能否同时与远地的两个套接字相连?
解答:不行。一个套接字只能和另一个远地套接字相连。
如果许多个客户同时访问同一个服务器，那么对千这种情况，请参考教材第6章图6~30及相应的文字解释。

### 问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?
解答:运输层的TCP协议是端到端(进程到进程)的协议，而数据链路层的HDLC协议则是仅在一段链路上的结点到结点的协议。此外，TCP的窗口机制和HDLC的也有许多区别。如TCP是按数据部分的字节数进行确认的，而HDLC则是以帧为确认的单位。需要注意的是，现在使用得最多的PPP链路层协议并不使用确认机制和窗口机制。因此像PPP协议这样的链路层协议就和运输层协议有相当大的区别 。

### 问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?
解答:在旧的OSI体系中，在数据链路层使用HDLC协议而在网络层使用X.25协议，这些协议都有确认机制和窗口机制，因而能够保证可靠传输。但是技术的进步使得链路的传输已经相当可靠了，因此在数据链路层和网络层重复地保证可靠传输就显得多余了。现在互联网在链路层使用的PPP协议和在网络层使用的IP协议都没有确认机制和窗口机制。如果出现差错就由运输层的TCP来处理(若使用UDP协议则运输层也不处理出错的问题)。

### 问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?
解答:显然，仅从TCP报文段的首部无法得知目的IP地址。因此，TCP必须告诉IP层此报文段要发送给哪一个目的主机(给出其IP地址)。此目的IP地址填写在IP数据报的首部中。

### 问题5-9在TCP传送数据时，有没有规定一个最大重传次数?
解答:我们知道以太网规定重传16次就认为传输失败，然后报告上层。但TCP没有规定最大重传次数，而是通过设置一些计时器来解决有关传输失败的问题。

### 问题5-10.TCP都使用哪些计时器?
解答:TCP共使用以下四种计时器，即重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下。
**重传计时器**
当 TCP 发送报文段时，就创建该特定报文段的重传计时器。可能发生两种情况:
(I) 若在计时器截止时间到来之前收到了对此特定报文段的确认，则撤销此计时器。
(2) 若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。
**持续计时器**
为了对付零窗口大小通知， TCP 需要另 一个计 时器。假定“接收 TCP" 给出了窗口大小 为零，“发送 TCP"就停止传送报文段，直到“接收TCP"发送确认并给出一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认报文段是不发送确认的。若确认丢失了，“接收TCP"并不知道，而是会认为它已经完成任务了，并等待着“发送TCP"接着会发送更多的报文段。但“发送TCP"由千没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。
要打开这种死锁，TCP为每一个连接使用一个待续计时器。当“发送TCP"收到一个窗口大小为零的确认时，就启动持续计时器。当持续计时器期限到时，“发送TCP"就发送一个特殊的报文段，叫做探测报文段。这个报文段只有一个字节的数据。它有一个序号，但它的序号永远不需要确认;甚至在计算对其他部分的数据的确认时，该序号也被忽略。探测报文段提醒接收TCP:确认已丢失，必须重传。
待续计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将待续计时器的值加倍和复位。发送端继续发送探测报文段，将持续计时器设定的值加倍和复位，直到这个值增大到门限值(通常是60秒)为止。在这以后，发送端每隔 60 秒就发送一个探测报文段，直到窗口重新打开。
**保活计时器**
保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保待静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处千打开状态。
要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段(每一个相隔75秒)还没有响应，就假定客户出了故障，这时就终止该连接。
**时间等待计时器**
时间等待计时器是在连接终止期间使用的。当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间，连接还处千一种中间过渡状态。这就可以使重复的FINC终止)报文段(如果有的话)可以到达目的站，从而可将其丢弃。这个计时器的值通常设置为一个报文段的寿命期待值的两倍。


### 问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?
解答:往返时间RTT只是对运输层的TCP协议才很重要，因为TCP要根据平均往返时间RTT的值来设置超时计时器的超时时间。
UDP没有确认和重传机制，因此RTT对UDP没有什么意义。
所以，不要笼统地说“往返时间RTT对运输层来说很重要“，因为只有TCP才需要计算RTT,而UDP不需要计算RTT。

### 问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?
解答:这时TCP显然无法利用已有的公式算出往返时间RTT。实际上TCP是选择(也就是猜测)一个比较长的时间作为初始的往返时间RTT。等到收到至少一个确认报文段时，才能利用公式计算出比较合理的往返时间 RTT。

### 问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?
解答: 糊涂窗口综合征产生的条件是: 当发送应用程序产生数据很慢，或接收应用程序读取数据(或消耗数据)很慢，或者两者都有。这时发送方和接收方都可能产生这种症状。
不管是上述情况中的哪一种，都使得发送数据的报文段很小，这就引起操作效率的降低。例如，若TCP发送的报文段只包括一个字节的数据，则意味着我们发送41字节的数据报(20字节的TCP首部和20字节的IP首部)才传送1字节的数据。数据的传送效率是1/41,它表示我们在非常低效率地使用网络的容量。

### 问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?
解答 :详细讨论如下。
**发送端产生的症状**
如果发送端为产生数据很慢的应用程序服务，例如，一次产生一个字节。这个应用程序一次将一个字节的数据写入发送端的TCP的缓存。如果发送端的TCP没有特定的指令，它就产生只包括一个字节数据的报文段。结果有很多41字节的IP数据报就在互联网中传来传去。
解决的方法是防止发送端的TCP逐个字节地发送数据。必须强迫发送端的TCP收集数据，然后用一个更大的数据块来发送。发送端的TCP要等待多长时间呢?如果等待时间过长，它就会使整个过程产生较长的时延。如果等待时间不够长，它就可能发送较小的报文段。Nagle找到了一个很好的解决方法。
**Nagle算法**
Nagle算法非常简单，但它能解决问题。这个算法是为发送端的TCP用的:
(I)发送端的TCP将它从发送应用程序收到的第一块数据发送出去，哪怕只有一个字节。(2)在发送第一个报文段(即报文段I)以后，发送端的TCP就在输出缓存中积累数据，
并等待:或者接收端的TCP发送出一个确认，或者数据已积累到可以装成一个最大的报文段，在这个时候，发送端的TCP就可以发送这个报文段。
(3)对剩下的传输，重复步骤2。这就是:如果收到了对报文段x的确认，或者数据已积累到可以装成一个最大的报文段时，那么就发送下一个报文段(x+1)。
Nagle算法的优点就是简单，并且它考虑到应用程序产生数据的速率，以及网络运输数据的速率。若应用程序比网络更快，则报文段就更大(最大报文段)。若应用程序比网络慢，则报文段就较小(小于最大报文段)。
**接收端产生的症状**
接收端的TCP可能产生糊涂窗口综合征，如果它为消耗数据很慢的应用程序服务，例如，一次消耗一个字节。假定发送应用程序产生了1000字节的数据块，但接收应用程序每次只读取1字节的数据。再假定接收端的TCP的输入缓存为4000字节。发送端先发送第一个4000字节的数据。接收端将它存储在其缓存中。现在缓存满了。接收端的TCP就通知窗口大小为零，这表示发送端必须停止发送数据。接收应用程序从接收端的TCP的输入缓存中读取第一个字节的数据。这时在输入缓存中就有了1字节的空间。接收端的TCP宣布其窗口大小为1字节，这表示正渴望等待发送数据的发送端的TCP会把这个宣布当作一个好消息，并发送只包括一个字节数据的报文段。这样的过程一直继续下去。一个字节的数据被消耗掉，然后再发送只包含一个字节数据的报文段。这又是一个低效率问题和糊涂窗口综合征(见图Q-5-14)
对于这种糊涂窗口综合征，即应用程序消耗数据比到达的慢，有两种建议的解决}」法。
**Clark解决方法**
Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，自到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。
**延迟的确认**
第二个解决方法是延迟一段时间后再发送确认。这表示当一个报文段到达时并不立即发送确认。接收端在确认收到报文段之前一直等待，直到缓存有足够的空间为止。延迟的确认防止了发送端的TCP滑动其窗口。当发送端的TCP发送完其数据后，它就停下来了。这样就防止了这种糊涂窗口综合征。
迟延的确认还有另一个优点:它减少了通信量。接收端不需要确认每一个报文段。但它也有一个缺点，就是迟延的确认有可能迫使发送端重传其未被确认的报文段。
可以用协议来平衡这个优点和缺点，例如，现在定义了确认的延迟不能超过500毫秒。

### 问题 5-15 为什么TCP什让汒连接盯小能每次都选择相同的、固定的初始序号?
解答:如果TCP在建立连接时每次都选择相同的、固定的初始序号，那么设想以下的情况:
(1)假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。
(2)假定每一次建立连接时，主机A都选择相同的、固定的初始序号，例如，选择l。
(3)假定主机A发送出的某些TCP报文段在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段。
(4)假定有一些在网络中滞留时间较长的TCP报文段最后终于到达了主机B,但这时传送该报文段的那个连接早已释放了，而在到达主机B时的TCP连接是一条新的TCP连接。这样，工作在新的TCP连接下的主机B就有可能会接受在旧的连接传送的、已经没有意义的、过时的TCP报文段(因为这个TCP报文段的序号有可能正好处在现在新的连接所使用的序号范围之中)，结果产生错误。
因此，必须使得迟到的TCP报文段的序号不处在新的连接中所使用的序号范围之中。
这样，TCP在建立新的连接时所选择的初始序号，一定要和前面的一些连接所使用过的序号不一样。所以，不同的TCP连接不能使用相同的初始序号。

### 问题 5-16. 能否利用 TCP 发送端和接收端交换报文段的图来说明慢开始的特点? 
解答:慢开始的特点可以用图 Q-5-16 来说明。
拥塞窗口cwnd的初始值是1(为方便起见，这里将拥塞窗口的单位设为报文段)。以后**每收到一个对新的报文段的确认，就将发送端的拥塞窗口cwnd加1。**
从图Q-5-16可以看出，拥塞窗口cwnd按照指数规律增长。所谓“新的报文段”就是指“未被确认过的报文段"。由千报文段在互联网中传输时，有可能在某个路由器处滞留一段时间，但以后又被交付接收端(重复交付)。接收端对每一个收到的无差错的报文段都可能给出确认。因此，对同一个报文段，发送端有可能收到几个重复的确认。但除了第一个确认可以使发送端拥塞窗口cwnd加1以外，对其余重复的报文段的确认都不能再使发送端拥塞窗口加1。


### 问题 5-17. 对于拥塞避免是否也能够用发送端和接收瑞交换的报文段来说明其工作原理?
解答:可以，但这只能是示意图。
因为在拥塞避免的开始，发送端的拥塞窗口 swnd=ssthresh,这时可以发送好几个报文段。 按照 RFC 2581 文档，每经过一个往返时间 RTT, 拥塞窗口就增加一个 MSS (最大报文段长 度)的大小(以字节为单位)。
在我们讨论原理时，以报文段个数作为窗口单位较为方便，因此在图 Q-5-17 中每经过一 个 RTT, 发送端拥塞窗口 swnd 就在 ssthresh 的基础上加1。
在图 Q-5-17 中将发送端发送报文段用一个粗箭头表示(因为这里面包含有许多个报文段， 很难一个个画出)，确认报文段也用一个粗箭头表示(这也可能有许多个确认报文段)，因此RTT也是概念性的往返时间。

### 问题 5-18. TCP连接很像一条连接发送端和接收端的双向管道。当 TCP在连续发送报文段时，若要管道得到充分的利用，则发送窗口的大小应怎样选择?
管道空间是有限的。当发送窗口很小时，管道在大部分时间内是比较空的,这说明在TCP连接中传输数据的效率比较低。当发送窗口增大时，管道逐渐被填满。发送管道一直是被填满的，这说明发送管道被利用得很充分。因为报文段的传输需要时间，因此对报文段的确认总是会滞后一段时间。
在单方向发送报文段(另一个方向发送确认)的情况下，发送管道和接收管道往往不能同时被充分利用(除非发送窗口的数值较大)。但如果双向都能发送数据报文段，那么发送管道和接收管道就都能够被利用得较充分。
我们还可看出，接收管道(即接收端发送确认报文段的管道)在任何情况下都没有填满。这是因为确认报文段很短，只需很短的时间就可发送出去。但接收一个数据报文段需要较多的时间，这就造成确认报文段不可能连续地从接收瑞发送出去。


### 问题5-19. 假定在一个互联网中，所有的链路的传输都不出现差错，所有的结点也都不会发生故障。试间在这种情况下， TCP 的”可靠交付"的功能是否就是多余的?
 解答:不是多余的。TCP的”可靠交付”功能在互联网中起着至关重要的作用。至少在以下所列举的情况下，TCP的”可靠交付”功能是必不可少的。
(I)每个IP数据报独立地选择路由，因此在到达目的主机时有可能出现失序。
(2)由千路由选择的计算出现错误，导致IP数据报在互联网中兜圈子。最后数据报首部中的生存时间TTL的数值下降到零。这个数据报在中途就被丢弃了。
(3)在某个路由器突然出现很大的通信量，以致路由器来不及处理到达的数据报。因此有的数据报被丢弃。
以上列举的问题表明了:必须依靠TCP的”可靠交付”功能才能保证在目的主机的目的进程接收到正确的报文。


### 问题5-20. TCP是通信协议还是软件?
解答:协议与实现协议的软件之间的区别，类似千编程语言的定义与编译器之 间的区别 。与编程语言的情况类似，编程语言的定义与编程语言通过编译器在计算机上的实现之间的区别有时也会比较模糊。大家与TCP软件打交道的机会远远比与TCP协议规范打交道的机会要多，因而会很自然地把某个协议的具体实现当作是协议的标准。尽管如此，我们必须明确地区分两者。
总之，TCP是通信协议，而不是一个软件。


### 问题5-21.在计算TCP的往返时间RTT的公式中，《计算机网络》教材过去的版本是取a=7/8。但在第6版和第7版中是取a=1/8。为什么会有这样大的改变?
解答:过去的版本是参考有的国外教材(例如，著名的Comer的《用TCP/IP进行网际互连》的卷1就是这样写的)，这本教材上把RTT的计算公式写为:
平均往返时延RTT=ax(旧的RTT)+(I-a)x(新的往返时延样本)而取a=7/8。
教材第6版和第7版中是考虑到最好和文档RFC6298的写法一致，这样可能会更加便于读者查阅比较权威的RFC文档。现在的RTT计算公式是:
新的RTTs=(l-a)x(旧的RTTs)+ax(新的RTT样本)
而取a=1/8。但这两种不同的写法在实质上并无不同，得出的计算结果是一样的。另外有些改动的地方是:
(1)RTT以前译为“往返时延"，现在改为“往返时间”。这样更加准确一些，因为RTT的后面一个T是Time,应当译为“时间”。以前用的"往返时延”来自"Round-TripDelay"。
(2)以前没有用RTTs这个符号，是为了使符号不要太多。现在看来，多用一个符号可能会更清楚一些(RFC文档也有这个符号，但他们使用的文本文件，不便千用下标，因此他们用的符号是SRTT,表示SmoothedRTT(平滑的RTT)。

### 问题 5-22 假定有一个应用程序需要知道报文从发送端到接收端所经受的时延。能否这样计算:从TCP获得往返时间RTT的数值。然后除以2?
解答:不行。RTT仅仅是TCP内部的数据，上层的应用程序无法从TCP获得RTT的数值。但应用程序可以模仿TCP的做法，即从应用层发送一个报文给对方，等收到确认后，就可算出报文的往返时间。把这个时间除以2,就得出报文从发送端到接收端所经受的时延。

### 问题 5-23. 教材上的图 5-7 在计算 UDP 检 验和时，为什么有的读者算出的“求和得出的 结果”是 1001011011101011, 而不是教材上给出的 10010110 1110110I?
解答:我们在进行二进制反码求和时，必须仔细地把进位加进去。
例如，先把最低位(右边数起的第1列)相加。这里一共有9个1,因此加出来的结果是10012。把1001中的最右面的1写在结果中，在它前面的100是进位。下面的图说明这三个进位应当放在哪一列。进位是l的就要和原来这一列上的数目相加。
再看第2列的相加。第2列一共有7个1,因此得到的和是1,但要有两个进位11。其中的一个l的位置应当是在从右边数起的第3列上，另一个1应当在第4列上。
然后再把第3列的数(包括进位上来的数)相加。
这样加下去，每一次都必须把前面得到的进位考虑进去。这样，一直加到最左边的第16列。
读者自己演算后就可发现，进行最左边的第16列的运算后，在第17列上(这已经超过了16位数的范围)有两个进位1。这两个1相加后的和是102。我们必须把这两个进位拿到最右边，再和刚才得到的、未考虑到最后的进位的初步计算结果相加，这就是“回卷"。刚才得到的计算初步结果是:
10010110 11101011
再加上 10后，得到
100IO110 11101101
这就是教材上给出的正确结果。

### 问题 5-24. TCP 的客户端和服务器端在交换数据时，为什么不含数据的确认报文段不消耗序号呢?
解答:我们知道， TCP把要传送的数据中的每一个字节都编上序号，其目的就是为了保 证每一个数据字节都能正确地传送到对方。接收方按字节的编号对收到的数据进行核对。用发送确认报文段的方法保证能够收到发送方发送的每一个数据字节。
但是，一个有趣的问题来了。纯粹的确认报文段并不带有数据。可是这种确认报文段却仍有序号。之所以出现这个序号，只是因为首部中有这样一个序号字段。我们可以用图Q-5-24来说明这个问题。
在图Q-5-24中，我们假定TCP通信的一方A要发送三个报文段总共发送300字节给B,每个报文段携带100字节的数据。A的报文段#1的序号是1。B收到后发送报文段#2。我们假定B现在的序号是5。A接着发送报文段#3。B发送确认报文段#4,其序号仍然是5。A再发送报文段#5。B发送确认报文段#6,其序号仍然是5。我们假定B现在要用报文段#7发送20个字节的数据给A,这个报文段的序号还是5。
为什么B发送的四个报文段的序号都是5呢?因为B发送的前三个确认报文段都不消耗序号。
但如果B在确认报文段中还带有数据，那么这种确认报文段当然要消耗序号。所消耗的序号数就是这个报文段携带的数据的字节数。
我们可以看出，即使B发送的前三个确认报文段都丢失了，有B的第四个报文段(即报文段#7)的ack=301就够了，A就知道自己所发送的数据，在序号300以前的(包括序号为300的)，B已经都收到了。可见给确认报文段编号是没有必要的。

### 问题 5-25. TCP 在连接建立时所发送的第一个 SYN 报文段只有首部，其数据部分是空的。 但为什么 SYN 报文段要消耗一个序号呢?
解答: TCP 在连接建立时所发送的第 一个 SYN 报文段是 一个控制报文段 ，其主要目的 是为了和对方建立同步，并明确自己采用的初始序号。这个报文段没有数据部分。按理说， 好像这个 SYN 报文段不需要序号。但是 SYN 报文段非常重要，是不允许丢失的(传错了或 丢失了就要重传，否则无法建立连接)，这就必须进行编号。虽然 SYN 报文段没有数据部分， 只有首部，但我们可以想象 SYN 报文段包含有一个虚字节的数据，因此给 SYN 报文段一个 序号，让 SYN 报文段消耗一个序号。当对方收到序号为 x 的 SYN 报文段后，给出的确认就 应当是 ack=x +Io 发送方收到这个确认，就知道发送的 SYN 报文段已正确地传送到对方了。

### 问题 5-26. TCP 在连接建立时，A发送SYN报文段，选择了初始序号seq=x。B收到连接请求报文段后，如同意建立连接，则向A发送确认和SYN报文段，其确认号是ack = x + 1, 同时也为自己选择一个初始序号 seq=y。 A 最后要发送确认报文段， 其序号是 seq= x + 1, 确认号是 ack = y + I 。这个确认 报文段消耗序号吗?
解答题目所说的 TCP连接建立的过程，如图Q-5-26所示。这就是教材上讲的“三报文握手”。
A所发送的确认报文段#3是不消耗序号的。
如果A在确认报文段#3之后接着发送数据报文段，那么这个数据报文段的序号就仍然是seq=x+I,因为确认报文段#3是不消耗序号的。
但是应当注意，如果A所发送的确认报文段#3携带了数据，那么这个报文段就消耗序号。
例如，A所发送的确认报文段#3携带了100字节的数据，那么A下一次发送的数据报文段#4的序号就应当是seq=x + 101。

### 问题 5-27. TCP 连接建立采用的 Three-Way Handshaking 的准确译名应当是怎样的? 
解答:过去很多人(包括本教材)把 Three-Way Handshaking 译为“三次握手”，但这是不准确的。
要建立 TCP 连接，客户端和服务器端的报文段交互的确需要三次，但这三次合起来应当算是一次握手的过程。也就是说，要建立 TCP 连接，需要客户和服务器双方进行一次握手， 但这种“一次“握手需要双方交换三个报文段 CA 到 B, B 到 A, A 再到 B)。现在，也有一 些人采用了“三向握手”这样的译名。但“三向”也有可能被理解为“三个方向“，这就不正确了。
在RFC 793中指出了，这种Three-Way Handshaking也就是“三报文握手”。因此，Three-Way Handshaking 最好是按意思译为“三报文握手”。

### 问题 5-28. TCP 报文段的长度有没有规定的最小值和最大值? 
解答:我们首先必须明确，在谈到 "TCP 报文段的长度”时，可能会有两种不同的理解。 
第一种理解是:这是指 TCP 报文段的总长度(首部和数据部分的长度之和)。 
第二种理解是:这是指 TCP 报文段数据字段的长度(不包括首部的长度)。 
这两种理解都是合理的。从字面上看，很自然会看到第一种理解是合理的。但我们知道，在 TCP 首部中的选项中有一个最大报文段长度 **MSS (Maximum Segment Size)**。这个 MSS 指 的是 TCP 报文段的数据字段的最大长度，并不包括首部。由于 MSS 是 TCP 协议正式使用的 名词，因此第二种理解也是很合理的。
这两种不同的理解有可能产生一些模糊不清的概念 。
为此，每当我们遇到 "TCP报文段长度”时，就应当弄清这里是指 "TCP 报文段的总长度”还是 "TCP报文段数据字段的长度”。
由于这两种长度仅仅相差一个 TCP 报文段的首部，因此在讨论 TCP 报文段长度的最小值和最大值时，可以随便采用上面的一种理解，只要说清楚是哪一种长度即可。
下面在讨论这个问题时，我们会采用很明确的表述方法，使读者不至千感到模糊不清 。
TCP 报文段的总长度显然有 一个最小值，这就是当 TCP 的数据字段的长度为零的情况 。例如，TCP的确认报文段，仅仅有一个固定长度 (20 字节)的首部，其数据字段的长度是零。在这种清况下， TCP 报文段的总长度就是最小值 20 字节。这种 TCP 的首部是没有选项的首部。
TCP 报文段总长度的最大值受以下两个方面的限制:
 (I) IP 数据报的总长度有 一 个规定的最大长度，即 **65535 字节**。如果使用 20 字节的固定长度IP首部，那么TCP报文段的总长度一定不能超过65515字节。如果超过了这个数值，必须在运输层分割报文段，使每一个TCP报文段不超过**65515**字节，否则无法封装成IP数据报。
(2)TCP报文段数据部分的长度不能超过最大报文段长度MSS值。我们知道，在TCP连接建立阶段，每一方要向对方说明自己所能接收的数据长度是多少(因为收到的数据要先存放在TCP的接收缓存中，如果数据太长就会放不下)。有人说，“在TCP的连接建立阶段，双方要协商MSS的数值"。但这种说法是错误的(在RFC879中专门指出这种说法是错误的，因为这里不存在什么协商)。通信的双方只是把自己的接收能力通知对方的TCP而已，并没有协商的过程。双方根据自己当时的具体条件给出的MSS值完全可以是不一样的。因此，TCP报文段的数据部分的长度肯定不能超过对方TCP给出的MSS数值。
这样，我们可以得出下面的表达式:
TCP报文段的总长度 ~Min[(对方给出的 MSS +TCP 首部)， 65515 字节]
这里假定了 IP 数据报使用 20 字节的固定长度 IP 首部。

### 问题 5-29. 能否这样讲:当我们在互联网上传送很长的大文件时，就必须使用 TCP 协议 而不是使用 UDP 协议?
解答 :上面的表述不全面。
当我们通过互联网传送很长的大文件时(例如，作为电子邮件的附件的大文件，或从某 个网站下载一个大文件)，一般都是使用了TCP协议，为的是保证在传送过程中不出现差错。我们都知道，一个大文件，只要在传送过程中间有一小点差错，就会导致整个大文件无法打开，就可以导致整个文件传送失败。因此，这种大文件的传送，几乎都不使用UDP来传送，因为UDP不能保证不出差错。接收端收到有差错的UDP报文段时(检验和不正确)，就简单地丢弃它。
但这也有例外的情况。
假设我们正在计算机上观看一个实时的流视频。这通常是个很长的文件，被分割成很多文件块并实时播送。这些文件块一个接一个地发送出去。如果运输层认为应当重传损坏或丢失的帧，那么整个传输的同步性就会丢失。观看者会突然看到一个空屏，然后需要等到第二次的传输到达。这是无法忍受的。但是，如果每一小块屏幕内容都用一个UDP用户数据报来传送那么接收方UDP就能简单地忽略损坏或丢失的分组，并将其他分组交付应用程序。部分屏幕可能会有非常短暂的空白，这对大多数观看者来说甚至都不会注意到。这就说明，在一些特殊情况下，不保证可靠传输的UDP协议也是很有用的。

### 习题与解答
### 【5-01 】 试说明运输层在协议栈中的地位和作用。运输层的通信和网络层的通信有什么 重要的区别?为什么运输层是必不可少的?
 解答:从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属千面 向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用 网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部 分中的路由器在转发分组时都只用到下三层的功能。
 从网络层来说，通信的两端是两个主机。 IP 数据报的首部明确地标志了这两个主机的 IP 地址。但“两个主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是 在主机中的进程，是这个主机中的 一 个进程和另一个主机中的一个进程在交换数据(即通信)。 因此严格地讲，两个主机进行通信就是两个主机中的应用进程互相通信。 IP 协议虽然能把分 组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运 输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是 应用进程之间的通信(见图 T-5-01)。因此，运输层是不可缺少的。
 所以运输层的通信和网络层的通信有很大的区别 。网络层 提供主机之间的逻辑通信，而 运输层则提供应用进程之间的逻辑通信。
运输层还有**复用、分用**的功能，还要对收到的报文进行**差错检测**。

### <5-02 > 网络层提供数据报或虚电路服务，对上面的运输层有何影响?
解答:网络层提供的两种服务的最大不同就是:数据报不提供可靠的交付，而虚电路服 务则提供可靠的交付。初看起来，似乎是如果网络层提供了可靠的交付，那么运输层就可以 简化一些，就不需要可靠交付了，因而可以简化一些。其实不然。事实证明，**即使网络层提供了可靠的交付，那也只是主机到主机的通信是可靠的，而我们需要的进程到进程的通信仍然可能出错。**因此，当必须保证可靠通信时，不管网络层提供多么可靠的服务，运输层仍然 必须有可靠交付的协议。因此，互联网在网络层只提供比较简单的数据报服务(这样就使得 网络层大大简化，使得网络的造价降低)，而用连接在网络上的主机中的运输层来实现可靠交付。可见对于互联网的设计，网络层的服务并没有对运输层的设计产生多大的影响 。

 ### <5-03 > 当应用程序使用面向连接的 TCP 和无连接的IP时，这种传输是面向连接的还是无连接的?
解答:这要在不同层次来看。在运输层是面向连接的，而在网络层则是无连接的。

### 【5-04】试画图解释运输层的复用。画图说明许多个运输用户复用到 一 条运输连接上， 而这条运输连接又复用到 IP 数据报上。
主机 H3 同时与主机凡和 H2进行通信。凡和 H3 的两个应用进程 (HTTP 和 SMTP) 进行通信，这需要使用两个 TCP 连接。这两个 TCP 连接所传送的报文段，使用下面的网络层的 IP 数据报传送。 H2 和 H3 的应用进程 (HTTP) 进行通信，这需要使用一个 TCP 连接。这个 TCP 连接所传送的报文段，也要使用下面的网络层的 IP 数据报来传送。在 网络层所传送的 IP 数据报己看不到运输层以上的复用情况。

### 【5-05】试举例说明有些应用程序愿意采用不可靠的 UDP, 而不愿意采用可靠的 TCP。 
解答:这可能有以下几种情况。 首先，在互联网上传输实时数据的分组时，有可能会出现差错甚至丢失。如果**利用 TCP协议对这些出错或丢失的分组进行重传，那么时延就会大大增加**。因此，实时数据的传输在运输层就应采用用户数据报协议UDP,而不使用TCP协议。这就是说，对千传送实时数据，我们宁可丢失少量分组(当然不能丢失太多，否则重放的质量就太差了)，也不要等待太晚到达的分组。在连续的音频或视频数据流中，很少量分组的丢失对播放效果的影响并不大(因为这是由人来进行主观评价的)，因而是可以容忍的。在这种情况下，我们愿意采用不可靠的UDP,而不愿意采用可靠的TCP。
其次，当网络出现拥塞时，TCP的拥塞控制就会让TCP的发送方放慢报文段的发送。可能**有的应用程序就不愿意放慢其报文段的发送速度**。另外，可能有的应用程序不需要TCP的可靠传输。在这些清况下，就宁可使用UDP来传送。

### <5-06 > 接收方收到有差错的 UDP 用户数据报时应如何处理? 
 解答:简单地丢弃 。

### <5-07> 如果应用程序愿意使用 UDP 完成可靠传输，这可能吗?请说明理由 。 
解答:这是可能的，但这要由应用层自己来完成可靠传输。例如，应用层自己使用可靠传输协议。当然，这还是需要相当大的工作量的。

### <5-08> 为什么说 UDP 是面向报文的，而 TCP 是面向字节流的?
解答:发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，如教材的图5-4所示。在接收方的UDP,对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了 IP 层的效率。

### <5-09 > 端口的作用是什么?为什么端口号要划分为三种?
解答: 端口是用来标志进程的。端口也就是协议端口号。但这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同 硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的 一种地址 。不同的系统，具体实现端口的方法可以是不同的(取决于系统使用的操作系统)。TCP/IP的运输层用一个16位端口号来标志一个端口。但端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网中不同的计算机中，相同的端口号是没有关联的。
两个计算机中的进程要互相通信，不仅必须知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号(为了找到对方计算机中的应用进程)。
端口号有三种。不同的端口类别有其特殊的用途。例如，客户端是通信的发起方，而服务器是服务的提供方。它们对端口的使用要求是不同的。这三种端口号是:
(I)熟知端口号或系统端口号，数值为0-1023。这些数值可在网址www.iana.org查到。IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。
(2)登记端口号，数值为1024-49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须按照IANA规定的手续登记，以防止重复。
上面两种端口号是服务器端使用的端口号。下面的一种是客户端使用的端口号。
(3)短暂端口号，数值为49152-65535。这类端口号**仅在客户进程运行时才动态选择，是留给客户进程选择暂时使用**。


### <5-10 > 试说明运输层中伪首部的作用 。
解答:所谓“伪首部”是因为这种伪首部并不是UDP用户数据报或TCP报文段真正的首部。只是在计算检验和时，临时添加在UDP用户数据报或TCP报文段的前面，得到—个临时的UDP用户数据报或TCP报文段。检验和就是按照这个临时的UDP用户数据报或TCP报文段来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算运输层的检验和。

### 【5-11 】 某个应用进程使用运输层的用户数据报UDP,然后继续向下交给IP层后，又封装成IP数据报。既然都是数据报，是否可以跳过UDP而直接交给IP层?哪些功能UDP提供了但IP没有提供?
解答:IP数据报只能找到目的主机而无法找到目的进程。如果应用进程直接把数据交给下面的IP层，那么在传送到对方IP层后，就只能交付目的主机，但不知道应当交付哪一个应用进程。**UDP提供对应用进程的复用和分用功能，以及提供对数据部分的差错检验**。这些功能IP层没有提供。

### 【5-12】 一个应用程序用UDP,到了JP层把数据报再划分为4个数据报片发送出去。结果前两个数据报片丢失，后两个到达目的站。过了一段时间应用程序重传UDP,而IP层仍然划分为4个数据报片来传送。结果这次前两个到达目的站而后两个丢失。试问:在目的站能否将这两次传输的4个数据报片组装成为完整的数据报?假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中。
解答:不行。重传时，IP数据报的标识字段会有另一个标识符。**仅当标识符相同的IP数据报片才能组装成一个IP数据报**。前两个IP数据报片的标识符与后两个IP数据报片的标识符不同，因此不能组装成一个IP数据报。

### 【5-13】 一个 UDP 用户数据报的数据字段为 8192 字节。在链路层要使用以太网来传送。 试问应当划分为几个 IP 数据报片?说明每一个 IP 数据报片的数据字段长度和片偏移字段的值。
解答: UDP用户数据报的长度=8192+8=8200B
**以太网数据字段最大长度是 1500 B**。若 IP 首部为 20 B, 则 IP 数据报的数据部分最多只能有 1480 B。 8200 = ]480 X 5 + 800, 因此划分的数据报片共 6 个。 数据字段的长度:前 5 个是 1480 字节，最后一个是 800 字节。 第 1 个数据报片的片偏移字节是 0。
第 2 个数据报片的片偏移字节是 1480 B。
第 3 个数据报片的片偏移字节是 1480 x 2 = 2960 B。 第 4 个数据报 片的片偏移字节是 1480 x 3 =4440 B。 第 5 个数据报片的片偏移字节是 I480 x 4 = 5920 B。 第 6 个数据报片的片偏移字节是 1480 x 5 = 7400 B。

### 【5-14】 一个 UDP 用户数据报的首部的十六进制表示是: 06 32 00 45 00 1C E2 17。试 求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报 是从客户发送给服务器还是从服务器发送给客户?使用 UDP 的这个服务器程序是什么?
解答:把 UDP 首部8个字节的数值写成二进制表示的数值，
源端口 0000011000110010, 其十进制表示是 1024 + 512 + 32 +16 + 2 = 1586。 
目的端口000000000100010I, 其十进制表示是64+4+l=69。
UDP 用户数据报总长度 00000000 00011100 , 其十进制表示是 16 + 8 + 4 = 28 字节。 数据部分长度是 UDP 总长度减去首部长度= 28- 8 = 20 字节。
此UDP用户数据报是从客户发给服务器(因为目的端口号<1023, 是熟知端口)。服务器程序是 TFTP C从教材 5.1.3 节的熟知端口号的表可查出)。

### 【5-15】使用 TCP 对实时话音数据的传输有没有什么问题?使用 UDP 在传送数据文件时会有什么问题?
解答:对实时话音数据的传输是不能使用 TCP 的。这是因为用 TCP 传输话音数据时， 只要一出现差错或丢失， TCP就要重传。 这就产生了额外的时延，有时这种时延会达到很高的数值，使接收方无法容忍。在实时话音通信中，我们宁可丢掉几个分组(这在重放时，还原的话音质量会差一些，但仍然可以听懂)，也不愿意收到太迟来到的分组，因为这样会使重 放的话音质量严重恶化。虽然 UDP 不保证可靠交付，但 UDP 比 TCP 的开销要小很多。因此 只要应用程序接受这样的服务质量就可以使用 UDP。
如果话音数据不是实时播放(边接收边播放)就可以使用 TCP, 因为 TCP 传输可靠。接收端用 TCP 将话音数据接收完毕后，可以在以后的任何时间进行播放。但本题目假定是实时话音数据传输，因此必须使用 UDP。
使用 UDP 传送数据文件时，如果出现了差错， UDP 仅仅是少收了这个出错的报文段 ， 并不通知发送方重传。这样就不能保证正确地传送数据。因此在传送数据文件时，我们都是采用 TCP 来传送的。

 ### <5-16 > 在停止等待协议中，如果不使用编号是否可行?为什么?
解答 :在停止等待协议中，如果不使用编号是不可行的。试考虑下面的例子(见图 T-5-16)。 A 发送报文段 M1, B 收到后发送确认(不编号)。但这个确认很晚才传送到 A。 A 在没有等到确认时，超时重传了 M1
B发送的第一个确认最后到了A, 千是A发送下一个报文段M2, 但M2丢失了。
B 收到 A 发送的重传的 M1, 。但 B 并不知道是重传的，因为报文段没有编号 。 B 无法判断是重传的老报文段，还是新的报文段。 B 只能把 A 发送的重传的 M, 收下，并发送确认。但 这个确认使 A 认为是对其发送的 M2 的确认，于是以为发送的两个报文段 B 都收到了。
这样简单的例子使我们看出，不使用编号， A 以为发送的两个报文段都正确地传送到 B, 而实际上 B 收到了两个重复的报文段。可见在停止等待协议中，如果不使用编号是不可行的。
