- [问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?](#问题-5-1-tcp-协议是面向连接的但-tcp-使用的-ip-协议却是无连接的这两种协议都-有哪些主要的区别)
- [问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?](#问题5-2-从通信的起点和终点来比较-tcp和ip的不同点是什么)
- [问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么?](#问题-5-3-ip和-udp-的一个共同点就是它们都是无连接-的-ip和-udp-最主要的区别是什么)
- [问题 5-4. 端口(port)和套接字(socket)的区别是什么?](#问题-5-4-端口port和套接字socket的区别是什么)
- [问题 5-5 一 个套接字能否同时与远地的两个套接字相连?](#问题-5-5-一-个套接字能否同时与远地的两个套接字相连)
- [问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?](#问题5-6数据链路层的hdlc协议和运输层的tcp协议都使用滑动窗口技术从这方面来进行比较数据链路层协议和运输层协议的主要区别是什么)
- [问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?](#问题5-7tcp协议能够实现可靠的端到端传输在数据链路层和网络层的传输还有没有必要来保证可靠传输呢)
- [问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?](#问题5-8在tcp报文段的首部中只有端口号而没有ip地址当tcp将其报文段交给ip层时ip协议怎样知道目的ip地址呢)
- [问题5-9在TCP传送数据时，有没有规定一个最大重传次数?](#问题5-9在tcp传送数据时有没有规定一个最大重传次数)
- [问题5-10.TCP都使用哪些计时器?](#问题5-10tcp都使用哪些计时器)
- [问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?](#问题-5-11-是否-tcp-和-udp-都需要计算往返时间-rtt)
- [问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?](#问题5-12假定tcp开始进行连接建立当tcp发送第一个syn报文段时显然无法利用教材中562节所介绍的方法计算往返时间rtt那么这时tcp又怎样设置重传计时器呢)
- [问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?](#问题-5-13-糊涂窗口综合征产生的条件是什么是否只有在接收方才产生这种症状)
- [问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?](#问题-5-14-能否更详细地讨论-一-下糊涂窗口综合征及其解决方法)
- [问题 5-18. TCP连接很像一条连接发送端和接收端的双向管道。当 TCP在连续发送报文段时，若要管道得到充分的利用，则发送窗口的大小应怎样选择?](#问题-5-18-tcp连接很像一条连接发送端和接收端的双向管道当-tcp在连续发送报文段时若要管道得到充分的利用则发送窗口的大小应怎样选择)
- [问题5-19. 假定在一个互联网中，所有的链路的传输都不出现差错，所有的结点也都不会发生故障。试间在这种情况下， TCP 的”可靠交付"的功能是否就是多余的?](#问题5-19-假定在一个互联网中所有的链路的传输都不出现差错所有的结点也都不会发生故障试间在这种情况下-tcp-的可靠交付的功能是否就是多余的)
- [问题5-20. TCP是通信协议还是软件?](#问题5-20-tcp是通信协议还是软件)
- [问题5-21.在计算TCP的往返时间RTT的公式中，《计算机网络》教材过去的版本是取a=7/8。但在第6版和第7版中是取a=1/8。为什么会有这样大的改变?](#问题5-21在计算tcp的往返时间rtt的公式中计算机网络教材过去的版本是取a78但在第6版和第7版中是取a18为什么会有这样大的改变)
- [问题 5-22 假定有一个应用程序需要知道报文从发送端到接收端所经受的时延。能否这样计算:从TCP获得往返时间RTT的数值。然后除以2?](#问题-5-22-假定有一个应用程序需要知道报文从发送端到接收端所经受的时延能否这样计算从tcp获得往返时间rtt的数值然后除以2)
- [问题 5-23. 教材上的图 5-7 在计算 UDP 检 验和时，为什么有的读者算出的“求和得出的 结果”是 1001011011101011, 而不是教材上给出的 10010110 1110110I?](#问题-5-23-教材上的图-5-7-在计算-udp-检-验和时为什么有的读者算出的求和得出的-结果是-1001011011101011-而不是教材上给出的-10010110-1110110i)
### 问题 5-1. TCP 协议是面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都 有哪些主要的区别?
解答:这个问题很重要，一定要弄清楚。
TCP 是面向连接的，但TCP所使用的网络则可以是面向连接的(如X.25网络)，但也可以是无连接的(如现在大量使用的IP网络)。选择无连接网络就使得整个系统非常灵活，当然也带来了一些问题。
显然，TCP提供的功能和服务要比IP所能提供的多得多。这是因为TCP使用了诸如确认、窗口通知计时器笘机制，因而可以检测出有差错的报文、重复的报文和失序的报文。

### 问题5-2. 从通信的起点和终点来比较， TCP和IP的不同点是什么?
解答: 
进程A和进程B的通信是使用面向连接的TCP提供的可靠的传输。
主机X和主机Y的通信是使用无连接的IP提供的不可靠的传输。
请注意:对TCP来说，通信的起点和终点是运输层上面的两个**套接字(socket)**,而应用层的应用进程正是通过应用层和运输层之间的套接字来使用TCP提供的服务。TCP协议根据报文段首部中的端口号找到目的端口，将报文段交付**目的进程**。请注意:套接字是由IP地址和端口号决定的，套接字也可称为“插口”。
对IP来说，通信的起点和终点是连接在网络上的两个**主机**。IP协议根据数据报首部中的目的IP地址找到目的主机，将数据报交付**目的主机**。
请注意可靠传输的范围和不可靠传输的范围是不同的 。
我们还应当注意的是:虽然在两个套接字之间的通信是面向连接的，但IP数据报在下面的网络中传输时是独立地选择路由，而**不是沿着某—条固定的路径传输**。然而在上面的端口看来，TCP报文段**好像都是从一个虚拟的、可靠的通信管道中传输到对方的端口的。**

### 问题 5-3. IP和 UDP 的一个共同点就是它们都是无连接 的 。IP和 UDP 最主要的区别是什么? 
解答: IP是**主机到主机**的通信协议，但UDP是**进程到进程**的通信协议。

### 问题 5-4. 端口(port)和套接字(socket)的区别是什么?
解答: 从教材经常使用的套接字定义来看，套接字包含了端口，因为**套接字**=(IP地址，端口号)。套接字是TCP连接的端点。套接字又称为"插口”。
但我们已经讲过，套接字(socket)有多种意思。当使用API时，套接字往往被看成是操作系统的一种抽象，这时，套接字和一个文件描述符是很相似的，并且是应用编程接口API的一部分。套接字由应用程序产生，并指明它将由客户还是服务器来使用。当应用进程创建一个套接字时，要指明该套接字使用的瑞门号。
**端口**则是应用层服务的一种代号，它用来标志应用层的进程。端口是一个16bit的整数。各种服务器使用的湍口号都是保留端口号，以便使客户能够找到服务器。例如万维网服务器使用的端口号是80。
在发送数据时，应用层的数据通过端口向下交付运输层。在接收数据时，运输层的数据通过适当的端口向上交付应用层的某个应用程序。

### 问题 5-5 一 个套接字能否同时与远地的两个套接字相连?
解答:不行。一个套接字只能和另一个远地套接字相连。
如果许多个客户同时访问同一个服务器，那么对千这种情况，请参考教材第6章图6~30及相应的文字解释。

### 问题5-6.数据链路层的HDLC协议和运输层的TCP协议都使用滑动窗口技术。从这方面来进行比较，数据链路层协议和运输层协议的主要区别是什么?
解答:运输层的TCP协议是端到端(进程到进程)的协议，而数据链路层的HDLC协议则是仅在一段链路上的结点到结点的协议。此外，TCP的窗口机制和HDLC的也有许多区别。如TCP是按数据部分的字节数进行确认的，而HDLC则是以帧为确认的单位。需要注意的是，现在使用得最多的PPP链路层协议并不使用确认机制和窗口机制。因此像PPP协议这样的链路层协议就和运输层协议有相当大的区别 。

### 问题5-7.TCP协议能够实现可靠的端到端传输。在数据链路层和网络层的传输还有没有必要来保证可靠传输呢?
解答:在旧的OSI体系中，在数据链路层使用HDLC协议而在网络层使用X.25协议，这些协议都有确认机制和窗口机制，因而能够保证可靠传输。但是技术的进步使得链路的传输已经相当可靠了，因此在数据链路层和网络层重复地保证可靠传输就显得多余了。现在互联网在链路层使用的PPP协议和在网络层使用的IP协议都没有确认机制和窗口机制。如果出现差错就由运输层的TCP来处理(若使用UDP协议则运输层也不处理出错的问题)。

### 问题5-8.在TCP报文段的首部中只有端口号而没有IP地址。当TCP将其报文段交给IP层时，IP协议怎样知道目的IP地址呢?
解答:显然，仅从TCP报文段的首部无法得知目的IP地址。因此，TCP必须告诉IP层此报文段要发送给哪一个目的主机(给出其IP地址)。此目的IP地址填写在IP数据报的首部中。

### 问题5-9在TCP传送数据时，有没有规定一个最大重传次数?
解答:我们知道以太网规定重传16次就认为传输失败，然后报告上层。但TCP没有规定最大重传次数，而是通过设置一些计时器来解决有关传输失败的问题。

### 问题5-10.TCP都使用哪些计时器?
解答:TCP共使用以下四种计时器，即重传计时器、持续计时器、保活计时器和时间等待计时器。这几个计时器的主要特点如下。
**重传计时器**
当 TCP 发送报文段时，就创建该特定报文段的重传计时器。可能发生两种情况:
(I) 若在计时器截止时间到来之前收到了对此特定报文段的确认，则撤销此计时器。
(2) 若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。
**持续计时器**
为了对付零窗口大小通知， TCP 需要另 一个计 时器。假定“接收 TCP" 给出了窗口大小 为零，“发送 TCP"就停止传送报文段，直到“接收TCP"发送确认并给出一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认报文段是不发送确认的。若确认丢失了，“接收TCP"并不知道，而是会认为它已经完成任务了，并等待着“发送TCP"接着会发送更多的报文段。但“发送TCP"由千没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。
要打开这种死锁，TCP为每一个连接使用一个待续计时器。当“发送TCP"收到一个窗口大小为零的确认时，就启动持续计时器。当持续计时器期限到时，“发送TCP"就发送一个特殊的报文段，叫做探测报文段。这个报文段只有一个字节的数据。它有一个序号，但它的序号永远不需要确认;甚至在计算对其他部分的数据的确认时，该序号也被忽略。探测报文段提醒接收TCP:确认已丢失，必须重传。
待续计时器的值设置为重传时间的数值。但是，若没有收到从接收端来的响应，则需发送另一个探测报文段，并将待续计时器的值加倍和复位。发送端继续发送探测报文段，将持续计时器设定的值加倍和复位，直到这个值增大到门限值(通常是60秒)为止。在这以后，发送端每隔 60 秒就发送一个探测报文段，直到窗口重新打开。
**保活计时器**
保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保待静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处千打开状态。
要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段(每一个相隔75秒)还没有响应，就假定客户出了故障，这时就终止该连接。
**时间等待计时器**
时间等待计时器是在连接终止期间使用的。当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间，连接还处千一种中间过渡状态。这就可以使重复的FINC终止)报文段(如果有的话)可以到达目的站，从而可将其丢弃。这个计时器的值通常设置为一个报文段的寿命期待值的两倍。


### 问题 5-11. 是否 TCP 和 UDP 都需要计算往返时间 RTT?
解答:往返时间RTT只是对运输层的TCP协议才很重要，因为TCP要根据平均往返时间RTT的值来设置超时计时器的超时时间。
UDP没有确认和重传机制，因此RTT对UDP没有什么意义。
所以，不要笼统地说“往返时间RTT对运输层来说很重要“，因为只有TCP才需要计算RTT,而UDP不需要计算RTT。

### 问题5-12.假定TCP开始进行连接建立。当TCP发送第一个SYN报文段时，显然无法利用教材中5.6.2节所介绍的方法计算往返时间RTT。那么这时TCP又怎样设置重传计时器呢?
解答:这时TCP显然无法利用已有的公式算出往返时间RTT。实际上TCP是选择(也就是猜测)一个比较长的时间作为初始的往返时间RTT。等到收到至少一个确认报文段时，才能利用公式计算出比较合理的往返时间 RTT。

### 问题 5-13. 糊涂窗口综合征产生的条件是什么?是否只有在接收方才产生这种症状?
解答: 糊涂窗口综合征产生的条件是: 当发送应用程序产生数据很慢，或接收应用程序读取数据(或消耗数据)很慢，或者两者都有。这时发送方和接收方都可能产生这种症状。
不管是上述情况中的哪一种，都使得发送数据的报文段很小，这就引起操作效率的降低。例如，若TCP发送的报文段只包括一个字节的数据，则意味着我们发送41字节的数据报(20字节的TCP首部和20字节的IP首部)才传送1字节的数据。数据的传送效率是1/41,它表示我们在非常低效率地使用网络的容量。

### 问题 5-14 能否更详细地讨论 一 下糊涂窗口综合征及其解决方法?
解答 :详细讨论如下。
**发送端产生的症状**
如果发送端为产生数据很慢的应用程序服务，例如，一次产生一个字节。这个应用程序一次将一个字节的数据写入发送端的TCP的缓存。如果发送端的TCP没有特定的指令，它就产生只包括一个字节数据的报文段。结果有很多41字节的IP数据报就在互联网中传来传去。
解决的方法是防止发送端的TCP逐个字节地发送数据。必须强迫发送端的TCP收集数据，然后用一个更大的数据块来发送。发送端的TCP要等待多长时间呢?如果等待时间过长，它就会使整个过程产生较长的时延。如果等待时间不够长，它就可能发送较小的报文段。Nagle找到了一个很好的解决方法。
**Nagle算法**
Nagle算法非常简单，但它能解决问题。这个算法是为发送端的TCP用的:
(I)发送端的TCP将它从发送应用程序收到的第一块数据发送出去，哪怕只有一个字节。(2)在发送第一个报文段(即报文段I)以后，发送端的TCP就在输出缓存中积累数据，
并等待:或者接收端的TCP发送出一个确认，或者数据已积累到可以装成一个最大的报文段，在这个时候，发送端的TCP就可以发送这个报文段。
(3)对剩下的传输，重复步骤2。这就是:如果收到了对报文段x的确认，或者数据已积累到可以装成一个最大的报文段时，那么就发送下一个报文段(x+1)。
Nagle算法的优点就是简单，并且它考虑到应用程序产生数据的速率，以及网络运输数据的速率。若应用程序比网络更快，则报文段就更大(最大报文段)。若应用程序比网络慢，则报文段就较小(小于最大报文段)。
**接收端产生的症状**
接收端的TCP可能产生糊涂窗口综合征，如果它为消耗数据很慢的应用程序服务，例如，一次消耗一个字节。假定发送应用程序产生了1000字节的数据块，但接收应用程序每次只读取1字节的数据。再假定接收端的TCP的输入缓存为4000字节。发送端先发送第一个4000字节的数据。接收端将它存储在其缓存中。现在缓存满了。接收端的TCP就通知窗口大小为零，这表示发送端必须停止发送数据。接收应用程序从接收端的TCP的输入缓存中读取第一个字节的数据。这时在输入缓存中就有了1字节的空间。接收端的TCP宣布其窗口大小为1字节，这表示正渴望等待发送数据的发送端的TCP会把这个宣布当作一个好消息，并发送只包括一个字节数据的报文段。这样的过程一直继续下去。一个字节的数据被消耗掉，然后再发送只包含一个字节数据的报文段。这又是一个低效率问题和糊涂窗口综合征(见图Q-5-14)
对于这种糊涂窗口综合征，即应用程序消耗数据比到达的慢，有两种建议的解决}」法。
**Clark解决方法**
Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，自到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。
**延迟的确认**
第二个解决方法是延迟一段时间后再发送确认。这表示当一个报文段到达时并不立即发送确认。接收端在确认收到报文段之前一直等待，直到缓存有足够的空间为止。延迟的确认防止了发送端的TCP滑动其窗口。当发送端的TCP发送完其数据后，它就停下来了。这样就防止了这种糊涂窗口综合征。
迟延的确认还有另一个优点:它减少了通信量。接收端不需要确认每一个报文段。但它也有一个缺点，就是迟延的确认有可能迫使发送端重传其未被确认的报文段。
可以用协议来平衡这个优点和缺点，例如，现在定义了确认的延迟不能超过500毫秒。

### 问题 5-18. TCP连接很像一条连接发送端和接收端的双向管道。当 TCP在连续发送报文段时，若要管道得到充分的利用，则发送窗口的大小应怎样选择?
管道空间是有限的。当发送窗口很小时，管道在大部分时间内是比较空的,这说明在TCP连接中传输数据的效率比较低。当发送窗口增大时，管道逐渐被填满。发送管道一直是被填满的，这说明发送管道被利用得很充分。因为报文段的传输需要时间，因此对报文段的确认总是会滞后一段时间。
在单方向发送报文段(另一个方向发送确认)的情况下，发送管道和接收管道往往不能同时被充分利用(除非发送窗口的数值较大)。但如果双向都能发送数据报文段，那么发送管道和接收管道就都能够被利用得较充分。
我们还可看出，接收管道(即接收端发送确认报文段的管道)在任何情况下都没有填满。这是因为确认报文段很短，只需很短的时间就可发送出去。但接收一个数据报文段需要较多的时间，这就造成确认报文段不可能连续地从接收瑞发送出去。


### 问题5-19. 假定在一个互联网中，所有的链路的传输都不出现差错，所有的结点也都不会发生故障。试间在这种情况下， TCP 的”可靠交付"的功能是否就是多余的?
 解答:不是多余的。TCP的”可靠交付”功能在互联网中起着至关重要的作用。至少在以下所列举的情况下，TCP的”可靠交付”功能是必不可少的。
(I)每个IP数据报独立地选择路由，因此在到达目的主机时有可能出现失序。
(2)由千路由选择的计算出现错误，导致IP数据报在互联网中兜圈子。最后数据报首部中的生存时间TTL的数值下降到零。这个数据报在中途就被丢弃了。
(3)在某个路由器突然出现很大的通信量，以致路由器来不及处理到达的数据报。因此有的数据报被丢弃。
以上列举的问题表明了:必须依靠TCP的”可靠交付”功能才能保证在目的主机的目的进程接收到正确的报文。


### 问题5-20. TCP是通信协议还是软件?
解答:协议与实现协议的软件之间的区别，类似千编程语言的定义与编译器之 间的区别 。与编程语言的情况类似，编程语言的定义与编程语言通过编译器在计算机上的实现之间的区别有时也会比较模糊。大家与TCP软件打交道的机会远远比与TCP协议规范打交道的机会要多，因而会很自然地把某个协议的具体实现当作是协议的标准。尽管如此，我们必须明确地区分两者。
总之，TCP是通信协议，而不是一个软件。


### 问题5-21.在计算TCP的往返时间RTT的公式中，《计算机网络》教材过去的版本是取a=7/8。但在第6版和第7版中是取a=1/8。为什么会有这样大的改变?
解答:过去的版本是参考有的国外教材(例如，著名的Comer的《用TCP/IP进行网际互连》的卷1就是这样写的)，这本教材上把RTT的计算公式写为:
平均往返时延RTT=ax(旧的RTT)+(I-a)x(新的往返时延样本)而取a=7/8。
教材第6版和第7版中是考虑到最好和文档RFC6298的写法一致，这样可能会更加便于读者查阅比较权威的RFC文档。现在的RTT计算公式是:
新的RTTs=(l-a)x(旧的RTTs)+ax(新的RTT样本)
而取a=1/8。但这两种不同的写法在实质上并无不同，得出的计算结果是一样的。另外有些改动的地方是:
(1)RTT以前译为“往返时延"，现在改为“往返时间”。这样更加准确一些，因为RTT的后面一个T是Time,应当译为“时间”。以前用的"往返时延”来自"Round-TripDelay"。
(2)以前没有用RTTs这个符号，是为了使符号不要太多。现在看来，多用一个符号可能会更清楚一些(RFC文档也有这个符号，但他们使用的文本文件，不便千用下标，因此他们用的符号是SRTT,表示SmoothedRTT(平滑的RTT)。

### 问题 5-22 假定有一个应用程序需要知道报文从发送端到接收端所经受的时延。能否这样计算:从TCP获得往返时间RTT的数值。然后除以2?
解答:不行。RTT仅仅是TCP内部的数据，上层的应用程序无法从TCP获得RTT的数值。但应用程序可以模仿TCP的做法，即从应用层发送一个报文给对方，等收到确认后，就可算出报文的往返时间。把这个时间除以2,就得出报文从发送端到接收端所经受的时延。

### 问题 5-23. 教材上的图 5-7 在计算 UDP 检 验和时，为什么有的读者算出的“求和得出的 结果”是 1001011011101011, 而不是教材上给出的 10010110 1110110I?
解答:我们在进行二进制反码求和时，必须仔细地把进位加进去。
例如，先把最低位(右边数起的第1列)相加。这里一共有9个1,因此加出来的结果是10012。把1001中的最右面的1写在结果中，在它前面的100是进位。下面的图说明这三个进位应当放在哪一列。进位是l的就要和原来这一列上的数目相加。
再看第2列的相加。第2列一共有7个1,因此得到的和是1,但要有两个进位11。其中的一个l的位置应当是在从右边数起的第3列上，另一个1应当在第4列上。
然后再把第3列的数(包括进位上来的数)相加。
这样加下去，每一次都必须把前面得到的进位考虑进去。这样，一直加到最左边的第16列。
读者自己演算后就可发现，进行最左边的第16列的运算后，在第17列上(这已经超过了16位数的范围)有两个进位1。这两个1相加后的和是102。我们必须把这两个进位拿到最右边，再和刚才得到的、未考虑到最后的进位的初步计算结果相加，这就是“回卷"。刚才得到的计算初步结果是:
10010110 11101011
再加上 10后，得到
100IO110 11101101
这就是教材上给出的正确结果。
